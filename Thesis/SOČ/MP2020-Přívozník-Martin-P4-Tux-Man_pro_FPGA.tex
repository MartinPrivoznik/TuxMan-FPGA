\documentclass{report}
\usepackage{ucs} 
\usepackage[utf8x]{inputenc} 	
\usepackage[czech]{babel}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{datetime}
\usepackage{titlesec}
\usepackage{interval}
\usepackage{multirow}
\usepackage{tikz-timing}
\usepackage{tikz}
\usepackage{listings}
\usepackage{nextpage}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\graphicspath{ {./Schematics/} }

\title{TuxMan - FPGA}
\titleformat{\paragraph}
\date{11/4/2019}
\author{Martin Přívozník}

\begin{document}
  \includepdf[page={1}]{FrontPage}
   \includepdf[page={2}]{FrontPage}
    \includepdf[page={3}]{FrontPage}
     \includepdf[page={4}]{FrontPage}
      \includepdf[page={5}]{FrontPage}
  \newpage
  \pagenumbering{gobble}

\newpage
\tableofcontents
\listoffigures
\listoftables
\clearpage
\chapter*{Seznam zkratek}
\begin{tabbing}
    např. \hspace{2em} \= například \\
    angl.  \>  anglicky \\
    tj.  \>  to je \\
    zkr.  \>  zkratka \\
    tzv. \> takzvaný, takzvaně \\
    ASIC  \>  Application-specific integrated circuit \\
    FPGA  \>  Field Programmable Gate Array \\
    RTL  \>  Register Transfer Level \\
   HDL \> Hardware Description Language \\
   FSM \> Finite State machine \\
   LUT \> LookUp Table \\
  ROM \> Read-Only Memory \\
 RAM \> Random-Access Memory \\
 VGA \> Video Graphics Array \\
 VHDL \> Very High Speed Integrated Circuit Hardware Description Language \\
 ZS \> Zakázaný Stav \\
 USB \> Universal Serial Bus \\
\end{tabbing}

\newpage
\pagenumbering{arabic}

\chapter*{Úvod}
\addcontentsline{toc}{chapter}{Úvod}
Počítačové systémy jsou v dnešní době nenahraditelnou součástí našich životů. Počítače můžeme nalézt naprosto všude, ať už se jedná o domácí počítače, přenosné počítače, automatizované systémy, nebo dokonce i o jednoduché kalkulačky. Dá se již říci, že svým způsobem řídí způsob, kterým žijeme. S rozvojem oboru počítačových systémů přichází čím dál tím více prostředků pro zjednodušení práce s nimi a minimalizaci nákladů. Nezbytnou součástí ve světě počítačů jsou vestavěné systémy, neboli jednoúčelové počítače. Narozdíl od univerzálních počítačů se většinou využívají pro konkrétní úlohu. Díky tomu mohou být jednodušší, optimalizovanější a mnohem levnější, než univerzální počítače. K vytvoření takového číslicového systému je nutné rozumět číslicovému návrhu, který je poté možné implementovat ve formě ASIC (angl. Application Specific Integrated Circuit, česky zákaznický integrovaný obvod) nebo například ve formě FPGA (angl. Field Programmable Gate Array, česky programovatelné hradlové pole). ASIC je digitální specializovaný obvod a je využíván za předpokladu, že tento obvod nebude dále potřebovat změnu ve funkčnosti a bude se vyrábět v sérii. V případě implementace do FPGA se počítá s tím, že FPGA je možné přeprogramovat a je vybráno v případě, kdy obvod bude vyžadovat změny v budoucnu, nebo již nebude třeba po vykonání malého počtu úloh. Především je také výrazně levnější než ASIC. \par

Příkladem využití počítačů jsou arkádové hry, které jsou zábavou pro celý svět již téměř od doby vynalezení počítačů. Jednou z těchto her je Pac-Man, který je známou hrou již od roku 1980. Pac-Man se stal symbolem pro mnoho dalších aplikací, jako jsou i televizní seriály a populární písně. Dodnes se jedná o velice populární hru.\par

Má práce se bude zabývat návrhem a implementací číslicového logického obvodu realizujícího klona Pac-Mana. Pro implementaci bude využita forma FPGA. Cílem práce je procvičení číslicového návrhu a realizace v programovatelném hradlovém poli. Značná část práce se tedy bude skládat z teorie potřebné k návrhu a implementaci.\par

V kapitole~\ref{sec:analyzachap} se budu věnovat teorii potřebné pro návrh a implementaci číslicového logického obvodu pro FPGA. V kapitole~\ref{sec:navrhhry} rozeberu postup návrhu číslicového obvodu na základě teoretických znalostí z předchozí kapitoly. Teorii využiji také k implementaci obvodu na vybrané FPGA v kapitole~\ref{sec:implementacechap}. Na konci v kapitole~\ref{sec:testovanichap} rozeberu postup testování práce.

\chapter{Analýza}\label{sec:analyzachap}
Tato kapitola obsahuje stručný souhrn znalostí a informací potřebných pro následný návrh a implementaci. V sekci~\ref{sec:cislicovynavrh} je vysvětlen číslicový obvod a postup jeho návrhu. V sekci~\ref{sec:fpga} stručně vysvětluji programovatelné hradlové pole a dále vybranou vývojovou desku. Sekce~\ref{sec:rozhrani} se zabývá použitými komunikačními rozhraními, které zajišťují uživatelský vstup a výstup. Na závěr kapitoly, v sekci~\ref{sec:hrapacman} vysvětluji princip a funkčnost hry, jenž je vzorem pro můj návrh.

\section{Číslicový návrh}\label{sec:cislicovynavrh}
V této sekci se věnuji tomu, co je číslicový obvod a jak jej navrhnout jak ve schématu, tak v jazyce popisujícím hardware. V podsekci~\ref{sec:kombinacniobvody} rozeberu logické funkce, prostředky jejich popisu a realizace pomocí logických hradel. Podsekce~\ref{sec:sekvencniobvody}  je zaměřená na návrh sekvenčních obvodů a synchronních sekvenčních automatů (FSM), na což naváže podsekce~\ref{sec:synchronniaasynchronninavrh}, ve které vysvěluji princip hodinových domén a plně sekvenčního návrhu. V podsekci~\ref{sec:jazykvhdl} stručně ukážu, jak převést schéma číslicového obvodu do kódu v jazyce popisujícím hardware (Hardware Description Language, HDL), v mém případě do jazyka Very High Speed Integrated Circuit Hardware Description Language (VHDL).


\subsection{Kombinační obvody}\label{sec:kombinacniobvody}
\subsubsection{Booleovská funkce}
Booleovská funkce je funkce $N$ vstupů a $M$ výstupů nad množinou $\{0, 1\}$. V případě, kdy má funkce více jak jeden výstup, lze ji rozdělit na $M$ funkcí s jedním výstupem. Uvážíme-li Booleovu algebru, platí pro operace sčítání a násobení pravidla uvedená v tabulce~\ref{tab:pravidla}. 
\begin{table}
\centering
\begin{tabular}{ c c c } 
	$a+ b = b + a$ & $a*b = b*a$ & (komutativita) \\
	$a+(b+c) = (a+b) + c$ & $a*(b*c) = (a*b)*c$ & (asociativita) \\
	$a+(b*c) = (a+b) * (a+c)$ & $a*(b+c) = (a*b) + (a*c)$ & (distributivita) \\
	$a+0 = a$ & $a*1 = a$ & (neutralita 0 a 1) \\
	$a + \overline{a} = 1$ & $a * \overline{a} = 0$ & (vlastnosti negace) \\
\end{tabular}
    \caption{Axiomy a vztahy Booleovy algebry.\cite{boole1854investigation}}
    \label{tab:pravidla}
\end{table}
Operace se dvěma vstupními hodnotami nazýváme binární operace. Některé binární operace, přestože často používají stejná značení + a * jako v algebře reálných čísel, mají v Booleově algebře stejnou prioritu a jiný význam (žádná operace nemá přednost)~\cite{kubatova}. Pro logický součet a logický součin platí základní pravidla v tabulce~\ref{tab:pravidlaboolalgebry}.
\begin{table}
\centering
\begin{tabular}{ c c c } 
	de Morgan & $\overline{(a+b)} = \overline{a} * \overline{b}$ & $\overline{(a*b)} = \overline{a} + \overline{b}$ \\
	idempotence & $a + a = a$ & $a * a = a$ \\
\end{tabular}
    \caption{Základní pravidla Booleovy algebry.\cite{kubatova}}
    \label{tab:pravidlaboolalgebry}
\end{table}
Příkladem reprezentace Booleovské funkce je pravdivostní tabulka~\ref{tab:andtable}, kde $in_1$ a $in_2$ jsou vstupní hodnoty a $out$ je výstupní hodnota. 
\begin{table}
\centering
\begin{tabular}{ |c c|c| } 
   	\hline
	$in_1$ & $in_2$ & $out$ \\
	\hline
	$0$ & $0$ & $f(0,0)$ \\
	$0$ & $1$ & $f(0,1)$ \\
	$1$ & $0$ & $f(1,0)$ \\
	$1$ & $1$ & $f(1,1)$ \\
   	\hline
\end{tabular}
    \caption{Pravdivostní tabulka.}
    \label{tab:andtable}
\end{table}
Pravdivostní tabulka obsahuje vždy $N^2$ řádků, aby reprezentovala výstupní hodnotu pro všechny možné kombinace vstupních hodnot. Další možností je Booleovská formule~.\cite{kubatova}. K vyjádření formule a k popisu booleovské funkce používáme nejčastěji základní funkce uvedené v tabulce~\ref{tab:logickefunkce}
\begin{table}
\centering
\begin{tabular}{ |c|c|c| } 
   	\hline
	Název & Pravdivostní tabulka & Formule \\
   	\hline
	AND (logický součin) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $0$ \\
		$0$ & $1$ & $0$ \\
		$1$ & $0$ & $0$ \\
		$1$ & $1$ & $1$ \\
	   	\hline
	\end{tabular} & $out = in_1*in_2$ \\
   	\hline
	NAND (negovaný logický součin) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $1$ \\
		$0$ & $1$ & $1$ \\
		$1$ & $0$ & $1$ \\
		$1$ & $1$ & $0$ \\
	   	\hline
	\end{tabular} & $out = \overline{in_1*in_2}$ \\
	\hline
	OR (logický součet) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $0$ \\
		$0$ & $1$ & $1$ \\
		$1$ & $0$ & $1$ \\
		$1$ & $1$ & $1$ \\
	   	\hline
	\end{tabular} & $out = in_1+in_2$ \\
	\hline
	NOR (negovaný logický součet) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $1$ \\
		$0$ & $1$ & $0$ \\
		$1$ & $0$ & $0$ \\
		$1$ & $1$ & $0$ \\
	   	\hline
	\end{tabular} & $out = \overline{in_1+in_2}$ \\
	\hline
	NOT (logická negace) & \begin{tabular}{ |c|c| } 
	   	\hline
		$in_1$ & $out$ \\
	   	\hline
		$0$ & $1$ \\
		$1$ & $0$\\
	   	\hline
	\end{tabular} & $out = \overline{in_1}$ \\
	\hline
	BUFFER (opakovač) & \begin{tabular}{ |c|c| } 
	   	\hline
		$in_1$ & $out$ \\
	   	\hline
		$0$ & $0$ \\
		$1$ & $1$\\
	   	\hline
	\end{tabular} & $out = in_1$ \\
	\hline
	XOR (nonekvivalence) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $0$ \\
		$0$ & $1$ & $1$ \\
		$1$ & $0$ & $1$ \\
		$1$ & $1$ & $0$ \\
	   	\hline
	\end{tabular} & $out = in_1 \oplus in_2$ \\
	\hline
	XNOR (ekvivalence) & \begin{tabular}{ |c c|c| } 
	   	\hline
		$in_1$ & $in_2$ & $out$ \\
	   	\hline
		$0$ & $0$ & $1$ \\
		$0$ & $1$ & $0$ \\
		$1$ & $0$ & $0$ \\
		$1$ & $1$ & $1$ \\
	   	\hline
	\end{tabular} & $out =\overline{in_1 \oplus in_2}$ \\
   	\hline
\end{tabular}
    \caption{Tabulka nejpoužívanějších základních logických funkcí.}
    \label{tab:logickefunkce}
\end{table}
\subsubsection{Kombinační obvod}
Kombinační logický obvod, je takový obvod, ve kterém jsou výstupní hodnoty dány pouze aktuální kombinací vstupních proměnných. Neobsahuje žádnou paměť předchozích stavů. Jedinou vyjímkou je krátký časový interval, za který logický člen (AND, NAND, OR, NOR ...) vyhodnotí výstup na základě vstupních hodnot. Tento časový interval může být zanedbatelný v případě krátkých datových cest. V případě dlouhé datové cesty může být potřeba na tento časový interval brát zřetel a zvážit optimálnější řešení. \par
Platí, že u číslicových obvodů každá proměnná v operaci nabývá hodnotu jednoho tzv. bitu. Bit je základní jednotkou dat a může nabývat hodnot $0$, nebo $1$. Reprezentací číslicového obvodu je schéma číslicového obvodu, kde každá z funkcí je reprezentována tzv. schématickou značkou. Schématické značky mohou být různé, dokud z nich jasně vyplívá, jakou funkci zastupují. Schématické značky jsou propojené signály, které představují jednotlivé bity. Pro minimalizaci je možné několik signálů (bitů) zakreslit jediným konektorem, pokud je označený počtem bitů, které reprezentuje. Nejčastěji používané normy značení jsou evropská a americká. Příklady schéma\-tických značek pro nejpoužívanější logické funkce jsou uvedené v tabulce~\ref{tab:functionschemes}. 
\begin{table}
\centering
\begin{tabular}{ c c } 
	AND & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/AND.png}} \\
	NAND & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/NAND.png}} \\
	OR & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/OR.png}} \\
	NOR & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/NOR.png}} \\
	NOT & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/NOT.png}} \\
	BUFFER & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/BUFFER.png}} \\
	XOR & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/XOR.png}} \\
	XNOR & \raisebox{-0.4\height}{\includegraphics[scale=0.6]{/Gates/XNOR.png}} \\
\end{tabular}
    \caption{Schématické značky některých nejpouživanějších základních logických funkcí (americká norma ANSI).}
    \label{tab:functionschemes}
\end{table}
Pro usnad\-nění práce můžeme využívat logických bloků, které plní danou funkci. Opět platí, že ze značení logických bloků ve schématu musí plně vyplívat, jakou funkci zastupují. Logický blok, který má definovanou funkci může být použit schématu. Při návrhu číslicových obvodů využíváme hierarchie, kde jsou pro každý logický blok popsány vstupy i výstupy a v případě, kdy se nejedná o základní logické bloky, tak je popsána i funkce (formule, pravdivostní tabulka, nebo schéma bloku) a vhodně přiřazena ke schématu. Jedním ze základních logických bloků je poloviční sčítačka, viz obrázek~\ref{fig:halfadder}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/HalfAdder.png}
\caption{Schéma poloviční sčítačky a příklad jejího značení ve schématu.}
\label{fig:halfadder}
\end{figure}
 Poloviční sčítačka umí sečíst dvě jednobitová čísla a vygenerovat bit do vyššího řádu (carry) podle pravdivostní tabulky~\ref{tab:halfaddertab}.
\begin{table}
\centering
 \begin{tabular}{ |c c|c c| } 
   	\hline
	$A$ & $B$ & $C$ & $\sum$ \\
   	\hline
	$0$ & $0$ & $0$ & $0$ \\
	$0$ & $1$ & $0$ & $1$\\
	$1$ & $0$ & $0$ & $1$\\
	$1$ & $1$ & $1$ & $0$\\
   	\hline
\end{tabular}
	\caption{Pravdivostní tabulka poloviční sčítačky.}
	\label{tab:halfaddertab}
\end{table}
Zřetězením dvou polovičních sčítaček a přenesením pomocí funkce OR získáme poté kompletní sčítačku, viz obrázek~\ref{fig:fulladder}.\cite{kubatova}
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/FullAdder.pdf}
\caption{Schéma kompletní sčítačky a příklad jejího značení ve schématu.}
\label{fig:fulladder}
\end{figure}
Kompletní sčítačka umí sečíst jednobitová čísla, vygenerovat bit do vyššího řádu a přijmout bit z nižšího, sčítá tedy tři bity. Sčítá počet jedniček na vstupech. \par
Pro porovnávání dvou hodnot a vyhodnocení jejich nerovnosti používáme tzv. komparátor, viz obrázek~\ref{fig:comparator}. 
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/Comparator.pdf}
\caption{Schéma komparátoru a příklad jeho značení ve schématu.}
\label{fig:comparator}
\end{figure}
Dalším důležitým základním logickým blokem je multiplexor, viz obrázek~\ref{fig:mux}.
\begin{figure}
\centering
\includegraphics[width=0.6\columnwidth]{/LogicalBlocks/Mux.pdf}
\caption{Schématická značka multiplexoru.}
\label{fig:mux}
\end{figure}
Multiplexor na základě řídícího vstupu/řídících vstupů ($a$) přivádí na výstup ($out$) jeden ze vstupních signálů ($x$). \par
Číslicový obvod lze realizovat například z integrovaných obvodů, v nichž bývají hradla realizována z několika tranzistorů. Logické hodnoty představuje napětí přivedené na obvod. Logická $1$ bývá reprezentována  napětím kladným a logická $0$ napětím nulovým.

\subsection{Sekvenční obvody}\label{sec:sekvencniobvody}
\subsubsection{Sekvenční logický obvod}
Sekvenční logický obvod je takový obvod, ve kterém výstupní hodnoty nejsou dány pouze aktuální kombinací vstupních proměnných, ale zároveň jeho vnitřním stavem. Sekvenční obvod si tedy musí zapamatovat předchozí hodnoty pomocí paměti, která bývá realizována pomocí zpětné vazby~\cite{kubatova}. Sekvenční obvod se dělí na dvě části - kombinační a paměťovou, kde paměťová část je tvořena logickým obvodem, ve kterém bývá zavedena zpětná vazba a kombinační část bývá tvořena kombinačním obvodem. Obecné schéma sekvenčního obvodu je na obrázku~\ref{fig:seqcircuit}. \par
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/sqcircuit.pdf}
\caption{Huffmanův model sekvenčního obvodu.}
\label{fig:seqcircuit}
\end{figure}
Příkladem logického obvodu se zpětnou vazbou může být tzv. RS klopný obvod, viz obrázek~\ref{fig:rsko}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/RSKO.pdf}
\caption{Schéma RS klopného obvodu s využitím logických hradel NOR.}
\label{fig:rsko}
\end{figure}
RS klopný obvod překlápí mezi dvěma mezními hodnotami. Pravdivostní tabulka RS klopného obvodu se může dělit na tři části - zakázaný stav (ZS), překlápěcí část a paměť, viz tabulka~\ref{tab:rskotab}.
\begin{table}
\centering
 \begin{tabular}{ |c c|c c| } 
   	\hline
	$A$ & $B$ & $Q$ & $Q'$ \\
   	\hline
	$0$ & $0$ & \multicolumn{2}{c|}{Z.S.} \\
	$0$ & $1$ & $0$ & $1$\\
	$1$ & $0$ & $1$ & $0$\\
	$1$ & $1$ & \multicolumn{2}{c|}{Paměť}\\
   	\hline
\end{tabular}
	\caption{Pravdivostní tabulka RS klopného obvodu s využitím NOR.}
	\label{tab:rskotab}
\end{table}
Pokud se tedy změní vstupní hodnoty z $[0,1]$, nebo $[1,0]$ na $[1,1]$, na výstupu bude předchozí hodnota, dokud neproběhne další změna vstupních hodnot. Jedná se tedy o tzv. hladinový klopný obvod (angl. latch). Častěji využívaným klopným obvodem je tzv. D klopný obvod, viz obrázek~\ref{fig:dko}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/DKO.pdf}
\caption{Schéma D klopného obvodu.}
\label{fig:dko}
\end{figure}
Výhodou D klopného obvodu je fakt, že narozdíl od RS klopného obvodu nemá zakázaný stav, viz pravdivostní tabulka~\ref{tab:dkotab}.
\begin{table}
\centering
 \begin{tabular}{ |c c|c c| } 
   	\hline
	$T$ & $D$ & $Q$ & $Q'$ \\
   	\hline
	\texttiming{LH} & $x$ & $x$ & $\overline{x}$\\
	\multicolumn{2}{|c|}{Jinak} & \multicolumn{2}{|c|}{Paměť}\\
   	\hline
\end{tabular}
	\caption{Pravdivostní tabulka D klopného obvodu.}
	\label{tab:dkotab}
\end{table}
Signál $T$ u D klopného obvodu se dá považovat za tzv. povolovací signál. Při náběžné hraně na $T$  (změna stavu z logické $0$ na logickou $1$) se na výstup $Q$ zapíše aktuální hodnota na signálu $D$. V tomto případě se tedy jedná o hranový klopný obvod. Příklad značení D klopného obvodu je na obrázku~\ref{fig:dblock}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/LogicalBlocks/DBlock.pdf}
\caption{Příklad značení D klopného obvodu ve schématu.}
\label{fig:dblock}
\end{figure}
Vstupní signál označený trojúhelníkem je signál T. Trojúhelník značí, že obvod mění výstupní hodnotu v reakci na náběžnou hranu. Tento vstup se jinak nazývá hodinovým vstupem. Pokud má číslicový obvod takový vstup jedná se o sekvenční obvod. V případě hladinového obvodu by ve značení mohl být místo trojúhelníku čtverec. \par
Hodnoty na signálech se dají popsat tzv. časovým diagramem. Časový diagram popisuje, jaké logické hodnoty nabývá daný signál v jaký čas. Příklad časového diagramu je na obrázku~\ref{fig:dkotd}.
\begin{figure}
\centering
\includegraphics[width=0.6\columnwidth]{/TimeDiagrams/DFlipFlop.pdf}
\caption{Časový diagram D klopného obvodu.}
\label{fig:dkotd}
\end{figure}
\par
Příkladem sekvenčního logického bloku je čítač. Čítač je takový sekvenční logický obvod, který uchovává v ,,paměti" informaci o tom, kolikrát zaznamenal změnu stavu (dle návrhu náběžnou, nebo sestupnou hrana) na hodinovém signálu. Příklad schématu čítače je na obrázku~\ref{fig:counter}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/Counter.pdf}
\caption{Příklad schématu dvoubitového čítače reagujícího na náběžnou hranu.}
\label{fig:counter}
\end{figure}
Může být ve schématu značen, jako na obrázku~\ref{fig:counterbox}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/LogicalBlocks/Counterbox.pdf}
\caption{Příklad schématické značky dvoubitového čítače reagujícího na náběžnou hranu.}
\label{fig:counterbox}
\end{figure}
\subsubsection{Konečný stavový automat}
Konečný stavový automat (angl. Finite State Machine - FSM) M je šestice M=(Q, T, D, $\delta$, $\lambda$, $q_0$), kde~\cite{jazykyapreklady}:
\begin{itemize}
  \item Q je konečná množina vnitřních stavů
  \item T je konečná množina vstupních symbolů (signálů)
  \item D je konečná množina výstupních symbolů (signálů)
  \item $\delta$ je zobrazení z Q x T do Q (stav x vstup do stav) nazývané přechodová funkce
  \item $\lambda$ je zobrazení z Q x T do D (Mealy, ze stavu a vstupu do výstupu) nebo Q do D (Moore, jen ze stavu do výstupu)
  \item $q_0$ je počáteční stav
\end{itemize}
Má definované stavy, mezi kterými za daných podmínek přepíná a mění svůj výstup. FSM provádí vždy právě jeden přechod s každou náběžnou hranou hodin. Musí popisovat přechodovou funkci (podmínky pro změnu stavu a do kterého), výstupní funkci (jaký signál v danou chvíli udává na výstup) a dále musí mít definovaný počátečný stav. Příklad stavového diagramu FSM je na obrázku~\ref{fig:fsmexample}, kde $a, b, c$ jsou podmínky pro změnu stavu a $q1, q2, q3$ jsou stavy FSM. Počáteční stav je značen šipkou, která nevychází z žádného stavu, v tomto případě $q1$.
\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (22.4,-28.4) circle (3);
\draw (22.4,-28.4) node {$q1$};
\draw [black] (39.9,-28.4) circle (3);
\draw (39.9,-28.4) node {$q2$};
\draw [black] (57.8,-28.4) circle (3);
\draw (57.8,-28.4) node {$q3$};
\draw [black] (25.4,-28.4) -- (36.9,-28.4);
\fill [black] (36.9,-28.4) -- (36.1,-27.9) -- (36.1,-28.9);
\draw (31.15,-27.9) node [above] {$a$};
\draw [black] (42.9,-28.4) -- (54.8,-28.4);
\fill [black] (54.8,-28.4) -- (54,-27.9) -- (54,-28.9);
\draw (48.85,-27.9) node [above] {$b$};
\draw [black] (55.587,-30.423) arc (-51.04855:-128.95145:24.636);
\fill [black] (24.61,-30.42) -- (24.92,-31.31) -- (25.55,-30.54);
\draw (40.1,-36.4) node [below] {$c$};
\draw [black] (15.5,-28.4) -- (19.4,-28.4);
\fill [black] (19.4,-28.4) -- (18.6,-27.9) -- (18.6,-28.9);
\end{tikzpicture}
\end{center}
\caption{Příklad stavového diagramu konečného stavového automatu.}
\label{fig:fsmexample}
\end{figure}
Rozeznáváme dva typy FSM na základě definičního oboru výstupní funkce~\cite{kubatova, jazykyapreklady}. Prvním typem je typ Mealy (angl. často input-based), který mění svůj výstup na základě aktuálního stavu a změn na vstupních signálech. Druhý je typ Moore (angl. často state-based), jehož výstupní funkce je závislá pouze na aktuálním stavu (každý stav má definovaný výstup). Příkladem stavového diagramu čítače modulo 4 s povolujícím vstupem je obrázek~\ref{fig:counterfsm}
\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (30.5,-22.2) circle (3);
\draw (30.5,-22.2) node {$q0/00$};
\draw [black] (53.2,-22.2) circle (3);
\draw (53.2,-22.2) node {$q1/01$};
\draw [black] (53.2,-41.8) circle (3);
\draw (53.2,-41.8) node {$q2/10$};
\draw [black] (30.5,-41.8) circle (3);
\draw (30.5,-41.8) node {$q3/11$};
\draw [black] (31.931,-19.572) arc (144.37918:35.62082:12.202);
\fill [black] (51.77,-19.57) -- (51.71,-18.63) -- (50.9,-19.21);
\draw (41.85,-13.98) node [above] {$CE\mbox{ }=\mbox{ }1$};
\draw [black] (55.984,-23.288) arc (60.10415:-60.10415:10.049);
\fill [black] (55.98,-40.71) -- (56.93,-40.75) -- (56.43,-39.88);
\draw (61.52,-32) node [right] {$CE\mbox{ }=\mbox{ }1$};
\draw [black] (19.5,-22.2) -- (27.5,-22.2);
\draw (19,-22.2) node [left] {$reset$};
\fill [black] (27.5,-22.2) -- (26.7,-21.7) -- (26.7,-22.7);
\draw [black] (51.63,-44.348) arc (-38.52063:-141.47937:12.5);
\fill [black] (32.07,-44.35) -- (32.18,-45.29) -- (32.96,-44.66);
\draw (41.85,-49.56) node [below] {$CE\mbox{ }=\mbox{ }1$};
\draw [black] (27.936,-40.262) arc (-129.04509:-230.95491:10.637);
\fill [black] (27.94,-23.74) -- (27,-23.85) -- (27.63,-24.63);
\draw (23.5,-32) node [left] {$CE\mbox{ }=\mbox{ }1$};
\draw [black] (33.287,-23.278) arc (96.59379:-191.40621:2.25);
\draw (38.43,-27.66) node [below] {$CE\mbox{ }=\mbox{ }0$};
\fill [black] (31.34,-25.07) -- (30.94,-25.92) -- (31.93,-25.81);
\draw [black] (54.87,-19.722) arc (173.74488:-114.25512:2.25);
\draw (59.72,-17.63) node [right] {$CE\mbox{ }=\mbox{ }0$};
\fill [black] (56.18,-22.02) -- (56.92,-22.6) -- (57.03,-21.61);
\draw [black] (55.834,-43.212) arc (89.53768:-198.46232:2.25);
\draw (60.47,-47.79) node [below] {$CE\mbox{ }=\mbox{ }0$};
\fill [black] (53.68,-44.75) -- (53.17,-45.55) -- (54.17,-45.55);
\draw [black] (29.391,-44.575) arc (5.94318:-282.05682:2.25);
\draw (24.94,-47.77) node [left] {$CE\mbox{ }=\mbox{ }0$};
\fill [black] (27.62,-42.61) -- (26.78,-42.19) -- (26.88,-43.19);
\end{tikzpicture}
\end{center}
\caption{Příklad stavového diagramu (typ Moore) čítače modulo 4 se vstupem count enable.}
\label{fig:counterfsm}
\end{figure}

\subsection{Synchronní návrh}\label{sec:synchronniaasynchronninavrh}
\subsubsection{Pravidla návrhu synchronního obvodu}
Synchronní obvod je takový obvod, ve kterém všechny sekvenční části obvodu mají na svůj hodinový vstup přivedený stejný signál, aby měnily svůj stav ve stejný čas. Tento signál můžeme nazývat společné hodiny. Společné hodiny mění svůj stav na dané frekvenci (nejčastěji dle krystalu v obvodu). Část obvodu se společným hodinovým signálem nazýváme hodinovou doménou~\cite{hodinovedomeny}. Pro návrh synchronního obvodu platí několik pravidel, které je nutné dodržet pro zajištění správné funkčnosti. Společné hodiny nesmí být hradlované (signál musí být přiveden přímo k hodinovým vstupům sekvenčních obvodů). V případě hradlování společných hodin může docházet k zákmitům a časovým rezervám v jednotlivých částech obvodu. Dále je nutné, aby obvod obsahoval synchronní reset. Po synchronním resetu obvodu změní stav celý obvod společně a nedojde k časovým nesrovnalostem~\cite{hodinovedomeny}. \par
Při návrhu se nemusí vždy pracovat pouze s jednou hodinovou doménou. Univerzální řešení přechodu mezi hodinovými doménami je dvoubranové FIFO se dvěma hodinovými vstupy.Pro zamezení nestabilit můžeme využít tzv. synchronizér. Synchronizér se skládá ze dvou D klopných obvodů zapojených v sérii, které zajistí podmínky pro korektní funkci ostatních klopných obvodů v cílové časové doméně. Vstupní hodnota D klopného obvodu nesmí být změněna krátce před příchodem náběžné hrany na hodinovém vstupu (tj. předstih). Zároveň nesmí být změněna těsně po příchodu náběžné hrany na hodinovém vstupu (tj. přesah)~\cite{hodinovedomeny}. V případě porušení těchto podmínek se může stát, že klopný obvod bude mít abnormálně zpožděnou, nebo kolísavou odezvu. Příklad synchronizéru je na obrázku~\ref{fig:synchronizer}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/LogicalBlocks/Synchronizer.pdf}
\caption{Příklad návrhu synchronizéru.}
\label{fig:synchronizer}
\end{figure}
\par
Datové signály jsou řízené řídícími signály. Protokol řídících signálů musí být navržen tak, aby se měnil vždy jen jeden. Příkladem řídících signálů mohou být signály "strobe" nebo "ack". Úkolem tohoto protokolu je indikace, zda jsou data aktuální. V případě tzv. jednosměrného handshake budou data aktuální po dobu, kdy signál "strobe" nabývá logické $'1'$. U tzv. oboucestného handshake jsou data platná a signál strobe bude nabývat logické $'1'$, dokud nepřijde od protistrany signál ACK.
\subsection{Jazyk VHDL}\label{sec:jazykvhdl}
\subsubsection{Charakteristika jazyka VHDL}
VHDL (VHSIC (Very-High-Speed Integrated Circuit, česky velmi rychlý integrovaný obvod) Hardware Description Language) je programovací jazyk sloužící pro popis hardware (tj. Hardware Description Language, zkr. HDL, česky jazyk popisující hardware). Používá se pro simulaci a návrh digitálních integrovaných obvodů, např. pro FPGA (Field of Programmable Gate Array, česky programovatelná hradlová pole). VHDL je silně typovaný jazyk a umožňuje popsat obvod na hradlové, RTL (Register Transfer Level, česky přenos na úrovni registrů) i algoritmické úrovni~\cite{vhdlI}.
\subsubsection{Datové typy}
VHDL je silně typovaný jazyk, při operacích je tedy nutné, aby se typy shodovaly. Jedny z důležitých základních datových typů jsou: bit, integer, std\textunderscore logic a std\textunderscore logic\textunderscore vector. 
\begin{itemize}
  \item Array - pole prvků jiného typu
  \item Bit - Výčtový typ ('0', '1')
  \item Integer - Celé číslo
  \item Std\textunderscore logic - Popis signálu ('U’,'X', '0',  ‘1', 'Z', 'W',  'L', 'H', '-')
  \item Std\textunderscore logic\textunderscore vector - Pole std\textunderscore logic
  \item Signed - Bitový vektor, který nepopisuje stav signálu, ale pouze číselnou hodnotu
  \item Unsigned - Signed, který může obsahovat pouze kladné hodnoty
\end{itemize}

\subsubsection{Základní konstrukce}
Konstrukce jazyka VHDL se dělí na několik částí~\cite{vhdlI}. Jednou z nich je tzv. entita. Entita popisuje pouze rozhraní, nikoliv chování nebo vnitřní strukturu návrhu. Obsahuje tedy definici vstupních a výstupních portů. Příklad návrhu entity multiplexoru se dvěma datovými vstupy $A, B$, jedním řídícím vstupem $SEL$ a výstupem $Y$:
\begin{lstlisting}[language=VHDL]
entity MULTIPLEXER is
port(   A, B, SEL 	: in bit;
	Y		: out bit
	);
end MULTIPLEXER;
\end{lstlisting}
Další částí je architektura. Architektura obsahuje chování a vnitřní strukturu entity. Architektura tedy musí být definována uvnitř entity a nelze, aby fungovala samostatně. Entita může obsahovat více architektur. Ta se poté dělí na dvě části. Deklarační a sekci paralelních příkazů. Deklarační část se nachází před klíčovým slovem begin a je vyhrazena pro deklaraci signálů, konstant, nebo typů. Součástí sekce paralelních příkazů může být instancování komponent, behaviorální popis (tj. popis chování), nebo tzv. procesy. Sekce paralelních příkazů se nachází v uvnitř architektury (tj. část za klíčovým slovem begin). Příklad architektury výše uvedeného multiplexoru:
\begin{lstlisting}[language=VHDL]
architecture MUX_BODY of MULTIPLEXER is

signal SELNON, ASEL, BSEL : std_logic;

begin

SELNON <= not SEL;
ASEL <= A and SELNON;
BSEL <= B and SEL;
Y <= ASEL or BSEL;

end MUX_BODY;
\end{lstlisting}
Proměnná označená klíčovým slovem signal značí stejnojmenný signál v obvodu. Klíčové slovo $std\textunderscore logic$ říká, že se jedná o jednobitový signál. V případě vícebitového signálu by bylo využito klíčové slovo $std\textunderscore logic\textunderscore vector$. Signál si pamatuje svou hodnotu, dokud není změněna dalším přiřazením. V části paralelních příkazů operátor $<=$ zastupuje operátor přiřazení. Hodnota z pravé strany je tedy po vyhodnocení logické operace přiřazena signálu na levé straně. Všechny logické operace v tomto případě jsou vyhodnocovány paralelně. Tato metoda se většinou využívá pro popis chování kombinačních obvodů. V případě popisu sekvenčního obvodu je nejčastěji využíván tzv. proces. Proces je součástí architektury a přestože popisuje sekvenční obvod, tak běží souběžně. V sekvenčním popisu je možné krom operátorů přiřazení a logických operací využívat také podmínky, jako je např. $if$, nebo $case$. V případě psaní syntetizovatelného kódu proces obsahuje citlivostní seznam a opět popis chování. Citlivostní seznam je seznam signálů, na který sekvenční obvod reaguje (u sekvenčních obvodů hodinový vstup). Příklad procesu, který popisuje D klopný obvod, kde $D$ je vstupní hodnota, $Q$ je výstupní, $clk$ jsou hodiny a $reset$ je synchronní reset:
\begin{lstlisting}[language=VHDL]
D_FLIP_FLOP : process (clk)
begin
	if(clk'event and clk='1') then       
		if(reset = '1') then
			Q <= '0';
		else 
			Q <= D;
		end if;
	end if;
end process;
\end{lstlisting}
Pokud na hodinách obvod zaznamená náběžnou hranu a není aktivní synchronní reset, tak na signál $Q$ zapíše aktuální hodnotu na signálu $D$. \par
Celý obvod je možné popsat v rámci jedné entity, pro přehlednost je možné ale využívat komponenty. Při návrhu většího obvodu je vhodné logicky oddělit části obvodů od sebe a vytvořit z nich entity, které je možné poté propojit v nadřazené entitě pomocí klíčového slova component a namapování vstupních a výstupních signálů jednotlivých entit pomocí příkazu port map. Při mapování je poté možné pouze přiřadit vstupní a výstupní signály komponenty k signálům v nadřazené entitě~\cite{vhdlI}.  
\subsubsection{Popis FSM}
Jazyk VHDL nezná pojem automatu a existuje mnoho způsobů, jak jej popsat ve VHDL. Často používaný popis a zároveň takový, který usnadní práci logické syntéze programu je metoda se třemi procesy~\cite{vhdlII}. Prvním procesem je přechodová funkce a jedná se o kombinační proces, který na základě vstupních hodnot vyhodnocuje, jaký bude příští stav FSM. Vstupy přechodové funkce jsou stavy a vstupy FSM a jejím výstupem je příští stav. Druhý proces je registr stavu, který je sekvenčním procesem. Jeho vstupem je příští stav a výstupem je nový aktuální stav. Příklad registru stavu, kde initial\textunderscore state je počáteční stav automatu, CURRENT\textunderscore STATE je aktuální stav a NEXT\textunderscore STATE je následující stav:
\begin{lstlisting}[language=VHDL]
CLKP : process (clk)
begin 
	if (clk'event and clk ='1') then 
		if (reset = '1') then
			CURRENT_STATE <= initial_state;
		else 
			CURRENT_STATE <= NEXT_STATE;
		end if;
	end if;
end process;
\end{lstlisting} 
Poslední proces je kombinační proces zvaný výstupní funkce, který na základě aktuálního stavu a v případě návrhu Mealyho FSM i vstupních hodnot vyhodnocuje výstup FSM. Výstupní funkce má jako vstupy stav a dle návrhu i vstup FSM. Výstupem je výstup FSM~\cite{vhdlII}. Příklad přechodové a výstupní funkce FSM s funkcí čítače modulo 4, kde T\textunderscore STATE je výčet stavů čítače, TRANSP je přechodová funkce a OUTP je výstupní funkce (Mealyho návrh):
\begin{lstlisting}[language=VHDL]
type T_STATE is (Q1, Q2, Q3, Q4);
signal CURRENT_STATE, NEXT_STATE : T_STATE;
begin
TRANSP : process (CURRENT_STATE, ce) 
begin 
	case CURRENT_STATE is 
		when Q1 => if ce='1' then 
				NEXT_STATE <= Q2;
			else 
				NEXT_STATE <= Q1;
			end if;
		when Q2 => if ce='1' then 
				NEXT_STATE <= Q3;
			else 
				NEXT_STATE <= Q2;
			end if;
		when Q3 => if ce='1' then 
				NEXT_STATE <= Q4;
			else 
				NEXT_STATE <= Q3;
			end if;
		when Q4 => if ce='1' then 
				NEXT_STATE <= Q1;
			else 
				NEXT_STATE <= Q4;
			end if;
		
	end case;
end process;

OUTP : process (CURRENT_STATE, ce)
begin
	case CURRENT_STATE is 
		when Q1 => if ce='1' then 
				q <= "01";
				else
				q <="00";
			end if;
		when Q2 => if ce='1' then 
				q <= "10";
				else
				q <="01";
			end if;
		when Q3 => if ce='1' then 
				q <= "11";
				else
				q <="10";
			end if;
		when Q4 => if ce='1' then 
				q <= "00";
				else
				q <="11";
			end if;
	end case;
end process;
\end{lstlisting} 

\section{Programovatelná hradlová pole FPGA}\label{sec:fpga}
Tato sekce se zabývá tím, co jsou programovatelná hradlová pole (Field of programmable gate array, FPGA) a jak probíhá práce s těmito hradlovými poli na vývojové desce. V podsekci~\ref{sec:dostupneprostredky} popisuji části FPGA, které jsou použity pro implementaci číslicového obvodu. Podsekce~\ref{sec:logickasynteza} stručně vysvětluje kroky nezbytné pro implementaci samotného číslicového obvodu na základě jeho popisu VHDL kódem. V podsekcích~\ref{sec:basys2} a \ref{sec:xilinxise} je stručně popsána použitá vývojová deska a vývojové prostředí, které se váže k FPGA, které deska obsahuje.

\subsection{Dostupné prostředky}\label{sec:dostupneprostredky}
\subsubsection{Základní stavební prvky}
Technologie FPGA využívá tří základních stavebních prvků. Jedním z nich je propojení. Propojení tvoří síť vodičů, které jsou propojeny MOS tranzistory nebo tzv. antipojistkami (nevodivý prvek, který je možné vnějším působením napětí prorazit a poté přejde do vodivého stavu). Dle nastavení buňky v konfigurační paměti jsou vodiče pomocí tranzistorů spojeny. Stejně jako u logických hradel pro tyto spínací prvky platí, že jejich odpor působí přídavné zpoždění. Při konfiguraci je tedy potřeba, aby FPGA vytvořilo specializovaný rozvod hodinového signálu, který zajistí, že signály budou správně načasovány~\cite{fpgatechnology}. Hodinový signál mívá stromovou topologii k zajištění co největší časové přesnosti v celém obvodu. \par Druhým základním stavebním prvkem jsou tzv. Look-up Tables (zkr. LUT). Pomocí programového propojení lze nakonfigurovat síť kombinačních prvků. FPGA využije části konfigurační paměti jako pravdivostní tabulky  k implementaci logické funkce. LUT může být zakreslen jako na obrázku~\ref{fig:lut}. 
\begin{figure}
\centering
\includegraphics[width=0.5\columnwidth]{/LogicalBlocks/lut.pdf}
\caption{Příklad zakreslení LUT.}
\label{fig:lut}
\end{figure}
\par Posledním stavebním prvkem jsou registry. Typicky ke každé logické funkci přísluší jeden registr. V FPGA převládají hranové D klopné obvody, které mají typicky vstup pro povolení hodin~\cite{fpgatechnology}. Základní blok může vypadat jako na obrázku~\ref{fig:basicblockfpga}. 
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/LogicalBlocks/fpgabasicblock.pdf}
\caption{Příklad základního bloku FPGA.}
\label{fig:basicblockfpga}
\end{figure}

\subsection{Logická syntéza}\label{sec:logickasynteza}
\subsubsection{Kroky logické syntézy}
Logická syntéza je proces, při kterém je popis hardware převeden do schématu, který užívá konkrétní dostupné prostředky daného FPGA. Proto se dá říct, že k dosažení nejlepších výsledků je potřeba navrhovat obvod s ohledem na cílovou technologii. Logická syntéza se skládá z několika kroků. Mezi důležité kroky patří syntéza, mapování a ,,place and route"~\cite{fpgastructure}. Úkolem syntézy je rozpoznání charakteristických bloků použitých v popisu hardware a vytvoření tzv. netlistu (tj. schéma z logických hradel). Nástroj musí umět rozpoznat aritmetické operátory, paměti, čítače, FSM, multiplexory a další bloky. V rámci syntézy probíhá také proces předoptimalizace, který např. vymaže nevyužité bloky v popisu a vysokoúrovňové datové typy, jako je například integer (označení celočíselného 32-bitového datového typu) přeloží do bitové reprezentace. Mapování řeší realizaci obvodu pomocí dostupných bloků FPGA. Jedná se o překlad z netlistu na dostupné stavební bloky. Úkolem place and route je napojit přeložené stavební bloky na ty, které obsahuje konkrétní čip a rozvést spoje v čipu tak, aby správně fungovalo např. časování obvodu. Po provedení těchto kroků je vytvořen tzv. bitstream, který je možné nahrát do paměti konkrétního FPGA.  
\subsection{Vývojová deska Digilent Basys 2}\label{sec:basys2}
\subsubsection{Specifikace}
Vývojová deska Digilent Basys 2~\cite{basys2rm} viz obrázek~\ref{fig:basys2}. 
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/Basys2/Basys2board.png}
\caption{Digilent Basys 2.}
\label{fig:basys2}
\end{figure}
je platforma pro návrh a implementaci logických obvodů. Deska obsahuje Spartan-3E FPGA od firmy Xilinx. Může pracovat s vestavěným oscilátorem, který lze nastavit na frekvenci $25$, $50$, nebo $100MHz$, nebo má připravený socket pro druhý externí oscilátor. Využívá XCF02 Flash ROM (Read Only Memory), ve které ukládá FPGA konfikurace na dobu neurčitou. Pracuje také s tzv. Pmods (analogové a digitální I/O (vstupní i výstupní) moduly, které dovolují například převod z analogového signálu na digitální a naopak). Má tři vestavěné stabilizátory napětí ($1.2V$, $2.5V$, $3,3V$), které dovolují využívat $3.5V-5.5V$ externí napájecí zařízení~\cite{basys2rm}. Typicky využívá napájení z USB, přes který může mít FPGA také naprogramováno, ale deska obsahuje také konektor pro baterii. Vstupní napájení je vedeno přes tzv. power switch. Deska musí být nakonfigurována pro vykonávání dané činosti. K vygenerování bitstreamu pro Spartan-3E FPGA je nutné použít vývojové prostřední od firmy Xilinx. Software od firmy Digilent zvaný Adept poté může být použit ke konfiguraci FPGA přes USB~\cite{basys2rm}.
\subsubsection{Dostupné prostředky}
Vývojová deska obsahuje čtyři tlačítka, osm přepínačů, které lze využít jako vstupy obvodu. Jako výstup lze využít osmi LED diod, nebo sedmisegmentového displeje. Sedmisegmentový displej na desce obsahuje čtyři číslice, které jsou připojeny na společné anodě (tzn. jsou aktivní při logické $'0'$). Krom těchto prvků obsahuje deska také PS/2 a VGA konektor (tříbitvé D/A převodníky pro červenou a zelenou barvu a dvoubitový převodník pro modrou) a konektory pro přídavné moduly.
\subsection{Vývojové prostředí Xilinx ISE}\label{sec:xilinxise}
\subsubsection{Uživatelské rozhraní}
Xilinx ISE je softwarový nástroj od firmy Xilinx pro syntézu a analýzu HDL návrhů~\cite{xiseman}. Umožňuje syntézu a simulaci návrhu, vytváření návrhů v jazycích VHDL nebo Verilog a konfiguraci FPGA (FPGA od firmy Xilinx, nikoliv od jiné). Primárním rozhraním je Project Navigator, ve kterém lze editovat zdrojový kód, sledovat výstupní konzoli a probíhající kroky syntézy viz obrázek~\ref{fig:xise}. 
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/ISE/xise.png}
\caption{Základní pohled na Xilinx ISE Project Navigator.}
\label{fig:xise}
\end{figure}
Okno hierarchie zobrazuje návrhové soubory (moduly), jejichž závislosti mají stromovou strukturu. Okno procesů popisuje operace, které bude ISE provádět na aktivním modulu (často syntéza, mapování, ...). Pro simulaci návrhu lze využít ISIM nebo ModelSim logického simulátoru, jejichž programy musí být také psané v HDL. Tyto simulátory zvládají primárně tyto typy simulací: Logické ověření (kontrola výstupů modulu),  ověření časování a simulace post-place and route (ověření chování po naprogramování FPGA)~\cite{xiseman}.

\section{Rozhraní}\label{sec:rozhrani}
Tato sekce popisuje komunikační rozhraní použitá v návrhu a implementaci, která zajišťují uživatelský vstup a výstup. V podsekci~\ref{sec:7segment} vysvětluji rozhraní 7-segmentového displeje. Sekce  \ref{sec:ps2} a \ref{sec:vga} popisují protokoly PS/2 a VGA.
\subsection{7-segmentový displej}\label{sec:7segment}
Sedmisegmentový displej se skládá ze sedmi uspořádaných LED diod viz obrázek~\ref{fig:sevensegment}.
\begin{figure}
\centering
\includegraphics[width=0.2\columnwidth]{/Basys2/sevenseg.jpg}
\caption{Sedmisegmentový displej.}
\label{fig:sevensegment}
\end{figure}
 Většina sedmisegmentových displejů obsahuje také osmou LED diodu, kterou využívá jako tečku. Jednotlivé segmenty je možné rozsvítit přivedením daného signálu (při zapojení na společnou katodu logickou $1$ a při zapojení na společnou anodu na logickou $0$). Častý způsob zapojení segmentů je na obrázku~\ref{fig:segmentconnection}.
\begin{figure}
\centering
\includegraphics[width=0.3\columnwidth]{/Basys2/segmentconn.png}
\caption{Příklad zapojení segmentů na sedmisegmentovém displeji.}
\label{fig:segmentconnection}
\end{figure}
Kombinacemi rozvícených segmentů lze vytvořit obrazy až 128 znaků.
\subsection{PS/2}\label{sec:ps2}
\subsubsection{Charakteristika}
Rozhraní PS/2 využívá dvoudrátové sériové komunikace (data a hodiny) většinou pro ovládání myši, nebo klávesnice. Při přenosu dat využívá jedenáctibitové slovo, které obsahuje tzv. start bit, stop bit, paritní bit a osmibitovou hodnotu ($1$ bajt), která představuje přenesenou informaci~\cite{ibmpc}. Pokud nejsou přenášena data, signály rozhraní PS/2 jsou v klidovém stavu v logické $1$. Při přenosu datový kabel sériově vysílá informace na frekvenci hodinového signálu. Časový diagram PS/2 přenosu je na obrázku~\ref{fig:ps2timing}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/TimeDiagrams/ps2.png}
\caption{Časový diagram PS/2 přenosu.}
\label{fig:ps2timing}
\end{figure}
\subsubsection{PS/2 klávesnice}
PS/2 klávesnice využívá skenovací kódy ke komunikaci se zařízením. Každá z kláves má přiřazený kód, který je odeslán při stisknutí, nebo puštění klávesy. V případě, že se jedná o speciální klávesu, nebo o puštění klávesy, tak může klávesnice přenést více jedenáctibitových slov v sérii. Při stisknutí speciální klávesy bývá odeslána informace $'11100000'$ (tj. $'E0'$ v hexadecimální soustavě) a po ní kód příslušné klávesy. Při puštění klávesy je odeslána hodnota $F0$. Například při puštění šipky směřující doleva (kód $6B$) jsou v sérii odeslány informace $E0,F0,6B$.
\subsection{VGA}\label{sec:vga}
\subsubsection{Charakteristika}
VGA je standard pro řadič zobrazující grafický výstup~\cite{ibmpc}. Využívá paralelního přenosu k předávání informací řadiči grafického výstupu. Přenáší synchronizační signály (HS - Horizontální synchronizace, VS - Vertikální synchronizace) a signály RGB (tj. signály definující vykreslovanou barvu). HS a VS dle své frekvence nastavují rozlišení monitoru a umožňují tedy časovou synchronizaci s monitorem, který vykresluje pixel po pixelu. Po příchodu synchronizačního signálu je třeba čekat daný čas, než se monitor sesynchronizuje (tj. časy back porch a front porch, viz obrázek ~\ref{fig:vgatiming}).
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/TimeDiagrams/vga.png}
\caption{Časový diagram VGA.}
\label{fig:vgatiming}
\end{figure}
RGB jsou analogové signály a hloubka vykreslované barvy je dána příslušným napětím (často $0 - 7V$)~\cite{ibmpc}.
\section{Hra Pac-Man}\label{sec:hrapacman}
Pac-Man je plošinová arkádová hra, ve které jde o ovládání žluté kuličky s ústy (Pac-Mana) v bludišti vyplněném tečkami, které má za úkol sníst. Krom Pac-Mana se v bludišti nachází také čtyři duchové, kteří se snaží Pac-Mana dohonit před tím, než stihne sníst všechny tečky v bludišti. Pokud některý z nich Pac-Mana chytí, tak je hráči odebrán jeden ze tří životů a hra začíná odznova uprostřed bludiště bez teček, které jsou již snězeny a duchové jsou vráceni zpět do tzv. domečku. Aby se Pac-Man mohl bránit duchům, tak se na mapě nachází čtyři větší tečky, po jejichž snězení může sníst i duchy, které se následně na chvíli zastaví v domečku a čekají na vyprchání efektu. Hra může být ovládána čtyřmi tlačítky, kde každé nastaví Pac-Manovi nový směr (dle tlačítka nahoru, dolu, doleva, doprava).  

\chapter{Návrh hry}\label{sec:navrhhry}
V této kapitole se zabývám návrhem obvodu pro finální implementaci. V sekci~\ref{sec:specifikacehry} rozeberu návrh hry jako celek. Sekce~\ref{sec:periferie} rozebírá návrh obvodu pro ovládání periferií (PS/2, VGA, sedmisegmentový displej). V sekci~\ref{sec:logikahry} vysvětluji návrh vnitřní logiky samotné hry a v sekci~\ref{sec:texturyvehre} poté propisování textur na výstup a inicializaci základních hodnot.

\section{Specifikace hry}\label{sec:specifikacehry}
V této sekci rozebírám konkrétní prvky hry a vysětluji návrhy pro jejich řešení. V podsekci~\ref{sec:cilachovani} popisuji, jak má hra fungovat jako celek. Podsekce~\ref{sec:hernimapanavrh} vysvětluje optimální návrh herního pole, na kterém se hra bude odehrávat a podsekce~\ref{sec:postavyachovani} popisuje chování postav na navrženém herním poli.
\subsection{Cíl a chování hry}\label{sec:cilachovani}
Cílem práce je navrhnout obvod realizující klon známé 2D arkádové hry a implementovat jej na vývojové desce Digilent Basys 2. Hráč bude moci hru ovládat pomocí šipek na PS/2 klávesnici a stav hry bude moci sledovat na VGA monitoru. Na začátku hry se hráčova postava (Tux-Man) objeví v bludišti, ve kterém se budou nacházet také čtyři duchové. Hráč bude muset pomocí šipek na klávesnici ovládat Tux-Mana a sbírat body rozložené na mapě zatímco nesmí přijít do styku s duchy. Body budou zobrazovány v hexadecimální soustavě na sedmisegmentový displej dostupný na vývojové desce. Tux-Man má tři životy na to, aby posbíral všechny body v bludišti. Životy bude možné sledovat na LED diodách na vývojové desce. Pokud hráče duchové třikrát chytí, tak bude hra zastavena a bude nutné resetovat obvod pro novou hru. Ve hře bude jedna hratelná úroveň, kde se duchové budou pohybovat stejnou rychlostí, jako Tux-Man.
\subsection{Herní mapa}\label{sec:hernimapanavrh}
Herní mapa bude navržena jako mřížka. Navrhuji rozdělit rozlišení VGA na matici, kde každá buňka má rozlišení $16×16$ pixelů. Z těchto buněk bude možné jednoduše vytvořit herní mapu s rozlišením $21×19$ buňek dle originální mapy. Výhodou tohoto řešení je možnost jednoduchého uchovávání informací o jednotlivých políčkách mapy v paměti a přistupování k těmto informacím dle souřadnic $x$ a $y$. Každý z herních prvků bude mít své souřadnice, které bude možné mezi sebou porovnávat. 
\subsection{Postavy a jejich chování}\label{sec:postavyachovani}
Každá z postav bude mít nastavený směr dle vnitřního signálu (u Tux-Mana ovládáno šipkami na klávesnici, u duchů řízeno automatem), na základě kterého se bude posouvat o jednu souřadnici v pravidelném časovém intervalu. Těsně před posunem postavy proběhne kontrola, co se nachází na souřadnicích před danou postavou dle nastaveného směru. Pokud se na souřadnicích před postavou nic nenachází, tak je posunuta. V případě Tux-Mana, pokud se bude jednat o bod, tak se daný bod smaže z paměti a Tux-Man je přesunut na jeho pozici a pokud se bude jednat o zeď, tak jeho souřadnice nebudou změněny. Duchové body budou ignorovat a pokud se před nimi bude nacházet zeď, tak pomocí generátoru náhodných čísel vyhodnotí nový směr. Duchové budou tedy náhodně měnit směr pokaždé, když dojdou ke zdi.

\section{Periferie}\label{sec:periferie}
V této sekci rozebírám návrhy číslicových logických obvodů pro komunikaci s periferiemi. V podsekci~\ref{sec:sedmisegmentdisplej} popisuji návrh pro ovládání sedmisegmentového displeje. Podsekce~\ref{sec:ps2sub} popisuje navržený obvod pro zpracování signálu z PS/2 klávesnice. a v sekci~\ref{sec:vgasub} poté vysvětluji obvod generující signály pro ovládání VGA rozhraní.

\subsection{Sedmisegmentový displej}\label{sec:sedmisegmentdisplej}
\subsubsection{Analýza}
Pro počítání bodů na sedmisegmentový displej jsem zvolil hexadecimální soustavu, každá číslice tedy bude mít čtyřbitový vstup. Na sedmisegmentovém displeji vývojové desky Digilent Basys 2 je možné na všech čtyřech číslicích zobrazovat v jednu chvíli pouze jednu hodnotu, ale každá z číslic má vlastní povolovací vstup (při logické $'0'$ svítí a při logické $'1'$ nesvítí) . Navrhuji tedy postupně přepínat aktivní číslice tak, aby byla v jednu chvíli aktivní pouze jedna a zároveň přepínat hodnotu, která je zobrazena na displeji. Pokud tak bude provedeno na frekvenci vyšší, než $30Hz$, tak lidské oko nebude schopno zachytit problikávání displejů a bude vytvořena iluze plynulého obrazu zobrazujícího jinou hodnotu na každé číslici. Problémem tohoto řešení je obnovovací frekvence sedmisegmentového displeje (při problikávání číslice na vysoké frekvenci nemusí vestavěné LED diody stíhat měnit svůj stav). Pokusím se tedy návrhem co nejvíce přiblížit minimální frekvenci nerozeznatelné lidským okem (zhruba třicet snímků za vteřinu).
\subsubsection{Návrh obvodu}
K docílení chtěné frekvence navrhuji využít čítač, který čítá v reakci na náběžnou hranu hodinového signálu ($50MHz$), jehož $x$-tý bit bude této frekvence dosahovat. Uvážíme-li čtyřčíslicový displej, frekvenci hodinového signálu $50MHz$ a pro každou číslici chtěnou frekvenci zhruba $30Hz$, tak bude platit následující:
\[(50*10^6)/2^x=4*30\]
\[\log_2  ((50*10^6)/120) = x\]
\[x = 18.67\]
Po zaokrouhlení na celé číslo dolů vyjde osmnáctý bit čítače, který se nejvíce přibližuje chtěné frekvenci. Z důvodu přepínání mezi čtyřmi číslicemi potřebujeme z čítače dva bity. Čítač tedy může vypadat jako na obrázku~\ref{fig:sscounter}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/SevenSegment/counter.pdf}
\caption{Čítač s vyvedeným osmnáctým a devatenáctým bitem.}
\label{fig:sscounter}
\end{figure}
Úkolem tohoto čítače bude paralelně přepínat aktivní vstupy a aktivní číslice na sedmisegmentovém displeji. K přepínání vstupů využiji multiplexor a k přepínání aktivní číslice dekodér 1 z 4. Ke správnému propsání číslice na displej musí být hodnota dekódována dekodérem na sedmisegmentový displej (pro přehlednost dle ASCII tabulky). Celý obvod může vypadat jako na obrázku~\ref{fig:wholeblock}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/SevenSegment/wholeblock.pdf}
\caption{Připojení sedmisegmentového displeje na čítač.}
\label{fig:wholeblock}
\end{figure}
Modul budu dále značit jako na obrázku~\ref{fig:block}.
\begin{figure}
\centering
\includegraphics[width=0.5\columnwidth]{/SevenSegment/block.pdf}
\caption{Značení modulu pro ovládání sedmisegmentového displeje.}
\label{fig:block}
\end{figure}
\subsection{PS/2}\label{sec:ps2sub}
Cílem je navrhnout modul, který zpracuje příchozí signál z klávesnice a na výstup bude posílat kód stisknuté klávesy, indikovat zda se jedná o speciální klávesu a zda je klávesa aktuální (strobe). Pro hru nebude nutné sledovat puštění kláves, ale pouze jejich stisknutí. Tento modul lze pro usnadnění navrhnout tak, aby přehlížel puštění klávesy. Kvůli o mnoho vyšší frekvenci oscilátoru na desce než je frekvence hodinového signálu PS/2 navrhuji využít synchronizér na oba signály PS/2 a pomocí detektoru sestupné hrany dle protokolu povolovat zápis dat do registrů. Pro uložení jedenáctibitového slova využiji jedenáctibitového posuvného registru s povolovacím vstupem (pokud je aktivní povolovací vstup, tak s náběžnou hranou hodinového vstupu všechny hodnoty předá o řád výš a zapíše vstupní hodnotu na nejnižší bit). Připojením detektoru sestupné hrany z hodinového signálu PS/2 na povolovací vstup posuvného registru docílíme zápisu jedenáctibitového slova do paměti. Obvod může být zakreslen jako na obrázku~\ref{fig:syncandload}.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/PS2/syncandload.pdf}
\caption{Návrh obvodu pro zpracování příchozích dat z klávesnice PS/2.}
\label{fig:syncandload}
\end{figure}
Výstupem druhého až devátého bitu posuvného registru (v obrázku jako $ps2\textunderscore key$) je informace o klávese. \par Pro detekci zda je klávesa aktuální nebo se jedná o speciální klávesu nebo o puštění klávesy jsem se rozhodl využít konečný stavový automat (FSM), který bude měnit hodnoty výstupů $strobe$ a $extended$ (speciální klávesa) na základě příchozích kláves. Pro kontrolu je potřeba, aby automat věděl, kdy je v registru hodnota klávesy aktuální. Výstupu indikujícího, že je informace v posuvném registru aktuální lze docílit připojením signálu $ps2\textunderscore clk\textunderscore edge\textunderscore detected$ k čítači modulo 11. Ze signálu přetečení čítače lze poté vyčíst, zda jsou všechna data načtena. Návrh obvodu je na obrázku~\ref{fig:fsmmind}, kde $OF$ je indikátor přetečení čítače.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/PS2/fsmmind.pdf}
\caption{Návrh obvodu pro detekci speciálních kláves a aktivity.}
\label{fig:fsmmind}
\end{figure}
FSM lze poté navrhnout se třemi stavy. Rozhodl jsem se využít Mealyho návrh FSM, viz obrázek~\ref{fig:ps2fsm}.
\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (16.6,-25.5) circle (3);
\draw (16.6,-25.5) node {$IDLE$};
\draw [black] (56,-34.1) circle (3);
\draw (56,-34.1) node {$EXT$};
\draw [black] (14.2,-46) circle (3);
\draw (14.2,-46) node {$REL$};
\draw [black] (13.701,-24.776) arc (283.71641:-4.28359:2.25);
\draw (10.9,-19.69) node [left] {$of\textunderscore flag\mbox{ }=\mbox{ }0\mbox{ }/$};
\fill [black] (15.41,-22.76) -- (15.71,-21.86) -- (14.74,-22.1);
\draw [black] (8,-25.5) -- (13.6,-25.5);
\draw (7.5,-25.5) node [left] {$reset$};
\fill [black] (13.6,-25.5) -- (12.8,-25) -- (12.8,-26);
\draw [black] (15.869,-22.603) arc (221.89492:-66.10508:2.25);
\draw (27.11,-17.16) node [above] {$of\textunderscore flag\mbox{ }=\mbox{ }1\mbox{ }\mbox{ }and\mbox{ }ps2\textunderscore key\mbox{ }!=\mbox{ }'E0',\mbox{ }'F0'\mbox{ }/\mbox{ }strobe$};
\fill [black] (18.46,-23.16) -- (19.38,-23) -- (18.72,-22.25);
\draw [black] (19.529,-24.853) arc (100.55144:54.82244:44.886);
\fill [black] (53.61,-32.29) -- (53.24,-31.42) -- (52.67,-32.24);
\draw (43.41,-23.82) node [above] {$of\textunderscore flag\mbox{ }=\mbox{ }1\mbox{ }and\mbox{ }ps2\textunderscore key\mbox{ }=\mbox{ }'E0'\mbox{ }/\mbox{ }$};
\draw [black] (18.041,-28.126) arc (23.29968:-36.65449:15.769);
\fill [black] (16.21,-43.78) -- (17.09,-43.43) -- (16.28,-42.84);
\draw (19.88,-36.31) node [right] {$of\textunderscore flag\mbox{ }=\mbox{ }1\mbox{ }and\mbox{ }ps2\textunderscore key\mbox{ }=\mbox{ }'F0'\mbox{ }/$};
\draw [black] (12.549,-43.502) arc (-152.55271:-220.80209:14.315);
\fill [black] (14.42,-27.55) -- (13.52,-27.83) -- (14.27,-28.48);
\draw (10.37,-35.12) node [left] {$of\textunderscore flag\mbox{ }=\mbox{ }1\mbox{ }/$};
\draw [black] (12.561,-48.499) arc (-5.53446:-293.53446:2.25);
\draw (7.73,-50.67) node [left] {$of\textunderscore flag\mbox{ }=\mbox{ }0\mbox{ }/$};
\fill [black] (11.22,-46.22) -- (10.47,-45.64) -- (10.38,-46.64);
\draw [black] (55.465,-31.16) arc (218.0546:-69.9454:2.25);
\draw (60.94,-26.9) node [above] {$of\textunderscore flag\mbox{ }=\mbox{ }0\mbox{ }/$};
\fill [black] (58.01,-31.89) -- (58.95,-31.79) -- (58.33,-31);
\draw [black] (53.07,-33.46) -- (19.53,-26.14);
\fill [black] (19.53,-26.14) -- (20.21,-26.8) -- (20.42,-25.82);
\draw (31.06,-30.99) node [below] {$of\textunderscore flag\mbox{ }=\mbox{ }1\mbox{ }/\mbox{ }ext,\mbox{ }strobe$};
\end{tikzpicture}
\end{center}
\caption{Stavový diagram FSM pro indikaci zda je klávesa aktuální, speciální, či se jedná o puštění klávesy.}
\label{fig:ps2fsm}
\end{figure}
Modul je možné dále značit, jako na obrázku~\ref{fig:ps2block}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/PS2/block.pdf}
\caption{Značení modulu pro PS/2.}
\label{fig:ps2block}
\end{figure}

\subsection{VGA}\label{sec:vgasub}
Cílem je navrhnout modul pro VGA, který bude generovat potřebné signály pro správnou funkci VGA monitoru (horizontální a vertikální synchronizace) a na výstup udávat informace o tom, který pixel (dle souřadnic) je právě vykreslován. Jednotlivé barvy bude měnit část obvodu spravující textury dle stavu hry. Pro práci využiji rozlišení 640 × 480 pixelů s frekvencí vykreslování pixelů $25.175MHz$. Specifikace tohoto VGA budou dle protokolu~\cite{vga}: 
\begin{itemize}
  \item Horizontal front porch: 16 taktů
  \item Horizontální synchronizační pulz: 96 taktů
  \item Horizontal back porch: 48 taktů
  \item Vertical front porch: 37 taktů
  \item Vertikální synchronizační pulz: 2 takty
  \item Vertical back porch: 60 taktů
\end{itemize}
K dosažení požadovené frekvence ($25.175MHz$) navrhuji využít toho, že hodinový signál na vývojové desce má frekvenci $50MHz$. Využiji jeden D klopný obvod k vydělení frekvence dvěma, viz obrázek~\ref{fig:vgacounter}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/VGA/counter.pdf}
\caption{Dělička dvěma.}
\label{fig:vgacounter}
\end{figure}
Signál counter je nyní možné připojit na povolovací signál dvou čítačů modulovaných dle specifikací a číst z nich hodnotu aktuálních souřadnic, viz obrázek~\ref{fig:vgapos}, kde výstup obvodu H-pos je $x$-ová souřadnice a V-pos je $y$-ová.
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/VGA/coordscount.pdf}
\caption{Obvod pro výpočet souřadnic vykreslovaného pixelu.}
\label{fig:vgapos}
\end{figure}
Pro resetování čítačů ve chvíli, kdy má souřadnice přejít na nulu využívám komparátor, ve kterém porovnávám hodnotu čítače s hodnotou uvedenou v protokolu VGA. Synchronizační signály budou vzhledem k předchozímu návrhu vysílány tak, aby byly pixely vykreslovány z levé strany do pravé a od shora dolu. K tomu poslouží výstupy H-pos a V-pos a jednoduchý komparátor, který vyhodnotí, zda se hodnota na souřadnicích nachází v rozmezí určeném pro vyslání synchronizačního signálu (v pixelech horizontální signál $656 - 736$ a vertikální $490 - 492$), viz obrázek~\ref{fig:syncpulses}.
\begin{figure}
\centering
\includegraphics[width=0.5\columnwidth]{/VGA/syncpulses.pdf}
\caption{Komparátory využité ke generování synchronizačních pulzů VGA.}
\label{fig:syncpulses}
\end{figure}
Modul budu dále označovat jako na obrázku~\ref{fig:vgablock}.
\begin{figure}
\centering
\includegraphics[width=0.4\columnwidth]{/VGA/vgablock.pdf}
\caption{Značení modulu VGA.}
\label{fig:vgablock}
\end{figure}
\par Kvůli kolísavosti vestavěného oscilátoru může vzniknout také malé kolísání obrazu. K zamezení by bylo možné dokoupit oscilátor pro VGA, se kterým by obvod mohl pracovat
\section{Logika hry}\label{sec:logikahry}
Tato sekce popisuje návrh obvodu pro vnitřní logiku hry. V podsekci~\ref{sec:mapajakomrizka} vysvětluji způsob navržení herní mapy. Sekce~\ref{sec:ovladanipostavy} popisuje návrh obvodu pro ovládání postavy na mapě a  sekce~\ref{sec:pohybduchu} se zabývá návrhem pro samovolný pohyb duchů po mapě.
\subsection{Herní mapa jako mřížka}\label{sec:mapajakomrizka}
Pro možnost pohodlné práce s prvky v mřížce doporučuji navrhnout modul, který bude měnit a kontrolovat stav hry (pozice jednotlivých prvků, jako jsou duchové, Tux-Man, zdi, body) na základě prvků v $16×16$ buňkách této mřížky. Tento modul prozatím nazvu stavový modul. Souřadnice $16×16$ buňky získáme ze čtvrtého až devátého bitu signálu H-Pos a V-Pos z VGA modulu. Nultý až třetí bit těchto signálů lze využít k vykreslování textur na základě souřadnic. Navrhuji tedy texturu pro každý herní prvek uložit do matice paměťových buňek $16×16$ (textury se nebudou přepisovat, můžeme tuto paměť tedy nazývat Read-Only Memory, česky paměť pouze ke čtení, zkr. ROM). Výstupem ROM s texturami budou aktuální hodnoty RGB s hloubkami dle možností, které poskytuje vývojová deska pro implementaci (tři bity pro hloubku červené barvy, tři bity pro hloubku zelené a dva bity pro hloubku modré). Pokud stavový modul bude navržen tak, aby jeho výstupy byly informace o pozici jednotlivých prvků na základě časování VGA (např. pokud VGA právě vykresluje pixel na souřadnicích [1,1], kde se nachází zeď, tak signál stavového modulu, který indikuje přítomnost zdi bude dosahovat logické $'1'$), tak lze těmito výstupy řídit multiplexor, který dle těchto řídících signálů udá na výstupy R,G a B požadované barvy (dle vybrané textury). Hrubý návrh obvodu pro výběr textur je na obrázku~\ref{fig:colorselect}.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/GameLogic/ColorDraw.pdf}
\caption{Hrubý návrh obvodu pro vykreslování textur do mřížky.}
\label{fig:colorselect}
\end{figure}
Součásti návrhu stavového modulu budu vysvětlovat v podsekcích~\ref{sec:pohybpomape},~\ref{sec:ovladanipostavy} a~\ref{sec:pohybduchu}.
\subsection{Pohyb postav po mapě}\label{sec:pohybpomape}
\subsubsection{Herní krok}
Navrhuji vybrat frekvenci pro pohyb postav okolo $2Hz$ (posun o buňku dvakrát za vteřinu), aby se hra dala stíhat, ale zároveň neprobíhala pomalu. Podobně jako u sedmisegmentového displeje v podsekci~\ref{sec:sedmisegmentdisplej} v sekci~\ref{sec:periferie} navrhuji využít čítač ke zpomalení hodinového signálu a získání chtěné frekvence. Za předpokladu, že chceme frekvenci blízkou $2Hz$, bude výpočet bitu čítače vypadat takto:
\[(50*10^6)/2^x=2\]
\[\log_2  ((50*10^6)/2) = x\]
\[x = 24.58\]
Hodnotu zaokrouhlím dolů, aby hra nebyla moc pomalá. S dvacátým čtvrtým bitem čítače vyjde frekvence dle výpočtu na $2.99Hz$. Herní krok navrhuji signalizovat v jednom taktu, abych předešel časovým komplikacím v pozdější fázi návrhu. Využiji tedy detektor náběžné hrany, abych docílil jednotaktového signálu zhruba třikrát do vteřiny. Tento signál nazvu step, viz obrázek~\ref{fig:gamestep}.
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/GameLogic/gamestep.pdf}
\caption{Návrh generátoru signálu indikujícího herní krok.}
\label{fig:gamestep}
\end{figure}
\subsubsection{Posun pohyblivých prvků s ohledem na zdi}
Každý z herních prvků (Tux-Man, duchové, body a zdi) bude mít v paměti uložené své souřadnice. Pro zdi a body navrhuji, z důvodu, že se na mapě nenachází pouze jednou a že nejsou pohyblivé, vytvořit matici paměťových buněk (u zdí se bude jednat o ROM a u bodů z důvodu, že se budou mazat z mapy při přejetí Tux-Manem, se bude jednat o Random-Access memory, zkratka RAM) a k nim přistupovat pomocí souřadnic. Pro Tux-Mana a každého z duchů navrhuji ukládat informace o souřadnicích ve vícebitových D klopných obvodech. Při změně souřadnic a příchodu herního kroku bude možné povolit zápis nových souřadnic. Modul pro každý pohyblivý prvek se tedy bude chovat jako velký D klopný obvod s povolovacím vstupem. Protože se postavy budou pohybovat pouze v mřížce v souřadnicích $21 × 19$, tak je možné, aby souřadnice $x$ a $y$ byly pětibitové signály. \par
Každý z pohyblivých prvků bude mít vlastní dvoubitový signál, který bude určovat jeho aktuální směr ($"00"$ bude reprezentovat směr nahoru, $"01"$ doleva, $"10"$ dolů a $"11"$ doprava). Návrh pro ovládání směrového signálu budu popisovat v podsekcích~\ref{sec:ovladanipostavy} a~\ref{sec:pohybduchu}. Pomocí signálu, který vybírá aktuální směr je možné předpovědět souřadnice pro další krok, viz obrázek~\ref{fig:newcoords}, kde signál $smer$ reprezentuje vybraný směr a $nove\textunderscore x$, $nove\textunderscore y$ jsou nové souřadnice a $krok\textunderscore povolen$ je signál, který bude aktivní, pokud proběhne herní krok a zároveň před pohyblivým prvkem nebude stát zeď.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/GameLogic/NewCoords.pdf}
\caption{Obecný návrh obvodu pro vyhodnocení následujících souřadnic pohyblivých prvků.}
\label{fig:newcoords}
\end{figure}
Se signály nabývajícími hodnoty předpokládaných souřadnic je nyní možné z ROM s informacemi o zdech vyčíst, zda se na daných souřadnicích nachází zeď, resp. zda se tam pohyblivý prvek může pohnout. Výstup této ROM bude logická $'1'$ pokud se zde zeď nachází a logická $'0'$ pokud nikoliv. Pokud tedy proběhne herní krok a na předpokládaných souřadnicích se nebude nacházet zeď, tak je možné pohyblivému prvku povolit postup na nové souřadnice (signál $krok\textunderscore povolen$). Návrh pro generování signálu $krok\textunderscore povolen$ je na obrázku~\ref{fig:stepenable}.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/GameLogic/StepEnabledGenerator.pdf}
\caption{Návrh obvodu pro generování signálu, který povoluje přepsání souřadnic.}
\label{fig:stepenable}
\end{figure}
\subsubsection{Optimalizace}
Kdyby se výše uvedený obvod implementoval pro každý pohyblivý prvek ve hře, tak by byla nutná inicializace paměti pro každý tento prvek (resp. každý z duchů a Tux-Man by měli svou vlastní paměť s informacemi o zdech na mapě). Důvodem je, že z jedné paměti může v jednu chvíli číst pouze jeden prvek, viz podsekce\ref{sec:implementproblems} v kapitole Implementace. Navrhuji tedy vytvořit si vlastní tzv. arbitrovaný přístup pro souřadnice jednotlivých pohyblivých prvků ve hře a každému z nich dát prioritu přístupu do paměti ve chvíli, kdy to potřebuje. Tux-Man bude přístup potřebovat pouze při herním kroku, aby obvod dokázal vyhodnotit, zda je možné ho posunout, nebo ne. Pro usnadnění práce s duchy doporučuji duchům střídat prioritu přístupu k paměti po celou dobu, pokud zrovna neprobíhá herní krok (jestli se budou moci posunout a kam bude vyhodnoceno dříve, než ve chvíli herního kroku). Arbitraci sběrnice je možné navrhnout pomocí čítače, dekodéru a multiplexoru, viz obrázek~\ref{fig:arbitrall}, kde ROM je paměť s informacemi o zdech na mapě, decoder $1 of N$ je dekodér jedna z $N$, vstupní signály multiplexoru jsou sjednocené souřadnice jednotlivých pohyblivých prvků a $ghost1 - ghost4$ je pojmenování duchů.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/GameLogic/ArbitrAll.pdf}
\caption{Návrh obvodu pro optimalizaci přístupu do paměti se zdmi.}
\label{fig:arbitrall}
\end{figure}
V tuto chvíli by každý z duchů měnil směr na základě stejného signálu $collision$. Navrhuji tedy jim za pomocí D klopných obvodů zapsat informaci $collision$ pouze ve chvíli, kdy na ně přijde řada. Tímto získáme signál s informací o kolizi každého ducha. U Tux-Mana nebude potřeba zapisovat informaci do paměti z důvodu, že tuto informaci využije pouze v jednom hodinovém taktu při příchodu herního kroku. Obvod pro uchování informace o kolizi ducha může vypadat jako na obrázku~\ref{fig:ghostinfo}, kde $x$ je číslo ducha.
\begin{figure}
\centering
\includegraphics[width=0.6\columnwidth]{/GameLogic/GhostCollision.pdf}
\caption{Návrh obvodu pro uchování informace o buňce před duchem.}
\label{fig:ghostinfo}
\end{figure}
\subsubsection{Sbírání bodů}
Jediná postava, která bude moci sbírat body bude Tux-Man. Navrhuji připojit souřadnice Tux-Mana na inicializovanou RAM se souřadnicemi bodů. Každá paměťová buňka v paměti bude nabývat logické $'1'$, pokud se na ni nachází bod a logické $'0'$ pokud nikoliv. Pokud v této RAM na souřadnicích Tux-Mana vynulujeme hodnotu ve chvíli, kdy na tyto souřadnice Tux-Man stoupne, tak se na výstupu paměti na jeden takt zobrazí informace o tom, zda se na buňce nachází bod, nebo ne. Tímto signálem je možné čítat počet bodů, které hráč nasbíral. Výstup tohoto čítače je možné připojit rovnou na sedmisegmentový displej. Návrh obvodu pro sbírání bodů je na obrázku~\ref{fig:pointcounting}, kde signály $tm\textunderscore pos\textunderscore x$, $tm\textunderscore pos\textunderscore y$ jsou souřadnice Tux-Mana a RAM score je paměť s informacemi o bodech, která obsahuje vnitřní implementaci pro vynulování paměťové buňky při čtení z dané souřadnice. 
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/GameLogic/PointCounter.pdf}
\caption{Návrh obvodu pro počítání bodů sebraných Tux-Manem.}
\label{fig:pointcounting}
\end{figure}
\subsection{Ovládání Tux-Mana}\label{sec:ovladanipostavy}
Pro ovládání Tux-Mana pomocí PS/2 modulu navrhuji využít dekodér, který přeloží vybranou klávesu na směrový signál definovaný v podsekci~\ref{sec:pohybpomape}. Tux-Manův směrový signál budu nazývat $tuxman\textunderscore directions$. Návrh obvodu pro ovládání Tux-Mana je na obrázku~\ref{fig:tuxcontrol}, kde dekodér udává při aktivním signálu $strobe$, $extended$ a daným kódem klávesy příslušný směr ($"00"$ při hodnotě $'75'$, $"01"$ při hodnotě $'6B'$, $"10"$ při hodnotě $'72'$, $"11"$ při hodnotě $'74'$).
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/GameLogic/PS2ToDirections.pdf}
\caption{Obvod pro ovládání Tux-Mana.}
\label{fig:tuxcontrol}
\end{figure}
\subsection{Ovládání pohybu duchů}\label{sec:pohybduchu}
Pro ovládání pohybu každého ducha navrhuji využít FSM. Dle sekce~\ref{sec:specifikacehry} může být FSM navržen tak, že duch bude mít nastaven jeden směr tak dlouho, dokud se před ním nebude nacházet zeď. Při posunu ke zdi navrhuji využít generátoru náhodných čísel a generovat dvoubitová náhodná čísla do té doby, dokud nedají dohromady směr, kterým není vůči duchovi zeď a poté může znovu čekat, dokud duch nedojde ke zdi. Vzhledem k tomu, že frekvence posunu postav je velmi nízká, tak je velmi malá pravděpodobnost (méně než tisícina procenta), že duch nestihne vyhodnotit další směr a bude posunut do zdi. Hrubý návrh obvodu pro ovládání duchů je na obrázku~\ref{fig:ghostcontrol}, kde Random number generator je generátor náhodných čísel, $x$ je číslo ducha a ghost x directions je směr, kterým duch míří.
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/GameLogic/GhostController.pdf}
\caption{Hrubý návrh obvodu pro ovládání duchů.}
\label{fig:ghostcontrol}
\end{figure}
Generátor náhodných čísel bude vnitřně implementován jako posuvný registr, který s každým taktem vyhodnotí pomocí logických hradel XOR novou hodnotu, kterou vloží na nejnižší bit. Generátor si lze představit jako na obrázku~\ref{fig:randomnum}~\cite{shiftregisters}
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/GameLogic/RandomNumGen.pdf}
\caption{Náčrt generátoru náhodných čísel.}
\label{fig:randomnum}
\end{figure}
Tento generátor náhodných se nazývá LFSM (angl. Linear-feedback shift register, česky Posuvný registr s lineární zpětnou vazbou). FSM pro nastavování směru lze navrhnout se čtyřmi stavy, kde každý stav reprezentuje směr, kudy duch může jít. Pokud kolizní signál ducha nabývá logické $'0'$, tak není třeba měnit směr. Pokud bude nabývat logické $'1'$, tak FSM přejde do nového stavu dle hodnoty na generátoru náhodných čísel. Je třeba ale brát v potaz, že kvůli sdílení ROM, která uchovává informace o zdech je nutné čekat čtyři takty na aktuální data. Toto je možné ošetřit připojením dvoubitového čítače a měnit stav automatu pouze tehdy, když tento čítač nabyde hodnoty $"11"$. Tento čítač bude tedy dalším vstupem FSM. Výstupem tohoto FSM musí být vždy směr dle stavu, ve kterém se nachází, aby bylo možné z paměti přečíst, zda se v novém směru nachází zeď. Hrubý stavový diagram FSM je na obrázku~\ref{fig:ghostfsm}
\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (23.8,-15.5) circle (3);
\draw (23.8,-15.5) node {$UP$};
\draw [black] (59.9,-14.7) circle (3);
\draw (59.9,-14.7) node {$LEFT$};
\draw [black] (23.8,-43.5) circle (3);
\draw (23.8,-43.5) node {$DOWN$};
\draw [black] (59.9,-42.6) circle (3);
\draw (59.9,-42.6) node {$RIGHT$};
\draw [black] (26.483,-14.159) arc (114.36313:68.17588:39.116);
\fill [black] (57.16,-13.48) -- (56.6,-12.72) -- (56.23,-13.65);
\draw (41.42,-9.48) node [above] {$random_number\mbox{ }=\mbox{ }"01",\mbox{ }counter\mbox{ }=\mbox{ }"11",\mbox{ }collision\mbox{ }=\mbox{ }'1'\mbox{ }/\mbox{ }ghost\mbox{ }directions\mbox{ }=\mbox{ }"01"$};
\draw [black] (20.946,-16.385) arc (314.968:26.968:2.25);
\draw (16.43,-14.23) node [left] {$collision\mbox{ }=\mbox{ }'0'$};
\fill [black] (21.36,-13.77) -- (21.15,-12.85) -- (20.44,-13.56);
\draw [black] (22.976,-46.372) arc (11.72631:-276.27369:2.25);
\draw (17.68,-48.98) node [below] {$-||-$};
\fill [black] (21.02,-44.59) -- (20.13,-44.27) -- (20.34,-45.25);
\draw [black] (62.442,-44.171) arc (86.00538:-201.99462:2.25);
\draw (65.04,-48.82) node [below] {$-||-$};
\fill [black] (60.2,-45.57) -- (59.64,-46.34) -- (60.64,-46.41);
\draw [black] (62.58,-13.377) arc (144:-144:2.25);
\draw (67.15,-14.7) node [right] {$-||-$};
\fill [black] (62.58,-16.02) -- (62.93,-16.9) -- (63.52,-16.09);
\draw [black] (22.81,-40.669) arc (-162.98169:-197.01831:38.161);
\fill [black] (22.81,-18.33) -- (22.1,-18.95) -- (23.05,-19.24);
\draw (20.64,-29.5) node [left] {$-||-$};
\draw [black] (24.498,-18.417) arc (11.86019:-11.86019:53.924);
\fill [black] (24.5,-40.58) -- (25.15,-39.9) -- (24.17,-39.7);
\draw [black] (59.335,-39.654) arc (-170.43329:-189.56671:66.211);
\fill [black] (59.33,-17.65) -- (58.71,-18.35) -- (59.69,-18.52);
\draw [black] (60.707,-17.589) arc (13.75511:-13.75511:46.519);
\fill [black] (60.71,-39.71) -- (61.38,-39.05) -- (60.41,-38.82);
\draw (62.54,-28.65) node [right] {$-||-$};
\draw [black] (26.749,-42.948) arc (99.76861:83.08766:104.057);
\fill [black] (26.75,-42.95) -- (27.62,-43.31) -- (27.45,-42.32);
\draw [black] (57.007,-43.394) arc (-75.89471:-101.24903:69.006);
\fill [black] (57.01,-43.39) -- (56.11,-43.1) -- (56.35,-44.07);
\draw (41.93,-45.99) node [below] {$-||-$};
\draw [black] (26.464,-16.88) arc (61.94647:44.26296:127.59);
\fill [black] (57.83,-40.43) -- (57.63,-39.51) -- (56.92,-40.2);
\draw [black] (57.235,-41.223) arc (-117.9959:-135.79467:126.774);
\fill [black] (25.87,-17.68) -- (26.07,-18.6) -- (26.78,-17.9);
\draw [black] (25.797,-41.261) arc (137.60544:119.55917:128.373);
\fill [black] (57.27,-16.15) -- (56.33,-16.11) -- (56.82,-16.98);
\draw [black] (57.887,-16.924) arc (-42.78604:-60.04935:134.124);
\fill [black] (26.42,-42.03) -- (27.36,-42.07) -- (26.86,-41.2);
\draw [black] (56.985,-15.408) arc (-77.45483:-100.00616:77.351);
\fill [black] (26.74,-16.08) -- (27.44,-16.71) -- (27.62,-15.73);
\draw [black] (13,-22.7) -- (21.3,-17.16);
\draw (12.39,-24.03) node [left] {$reset$};
\fill [black] (21.3,-17.16) -- (20.36,-17.19) -- (20.92,-18.02);
\end{tikzpicture}
\end{center}
\caption{Stavový diagram FSM pro vyhodnocení nového směru ducha.}
\label{fig:ghostfsm}
\end{figure}
Z důvodu obsáhlejšího návrhu se v obrázku nachází pouze několik ukázkových přechodových podmínek, ze kterých ostatní vyplívají. Počátečný stav je směr nahoru, aby duchové na začátku vyjeli ze svého hnízda dle návrhu mapy, viz podsekce~\ref{sec:texturyvehre}.
\section{Inicializace pamětí}\label{sec:texturyvehre}
\subsection{Textury}\label{texturyimpl}
Textury budou navrženy v matici paměťových buňek $16×16$, kde každá buňka bude nabývat osmibitové hodnoty, viz sekce~\ref{sec:logikahry}. Inspirací budou tedy kresby $16×16$ pixelů. Duchy navrhuji inicializovat jako na obrázku~\ref{fig:tuxman}.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/TuxMan/Ghosts.png}
\caption{Návrh textur duchů.}
\label{fig:ghosts}
\end{figure} 
Tux-Man bude vypadat jako žluté kolečko, viz obrázek~\ref{fig:ghosts}.
\begin{figure}
\centering
\includegraphics[width=0.3\columnwidth]{/TuxMan/TuxMan.png}
\caption{Návrh textury Tux-Mana.}
\label{fig:tuxman}
\end{figure} 
Zdi navrhuji udělat jako jednoduchý modrý čtverec a body jako menší bílé kolečko, viz obrázek~\ref{fig:wallandpoint}.
\begin{figure}
\centering
\includegraphics[width=0.5\columnwidth]{/TuxMan/WallAndPoint.png}
\caption{Návrh textury pro zeď a bod na mapě.}
\label{fig:wallandpoint}
\end{figure} 
Pokud nebude na místě žádná z těchto textur, tak navrhuji vykreslovat pouze černou barvu na pozadí.
\subsection{Základní pozice prvků hry}
Základní pozice prvků budou v paměti uloženy stejným způsobem jako textury, viz podsekce~\ref{sec:texturyimpl} s tím rozdílem, že tyto paměti budou uchovávat logickou $'0'$, nebo logickou $'1'$. Logická $'0'$ reprezentuje nepřítomnost prvku, logická $'1'$ reprezentuje přítomnost. Např. paměti pro zdi a body budou uchovávat po inicializaci data v matici stejně, jako je na obrázku~\ref{fig:gamemap}, kde modré pole je zeď (v paměti se zdmi logická $'1'$), pole s bílou tečkou je bod a černé pole je prázdné v obou pamětech jako logická $'0'$.
\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{/TuxMan/Map.png}
\caption{Mapa hry.}
\label{fig:gamemap}
\end{figure}
Základní pozice Tux-Mana bude na souřadnicích v mřížce $[9;15]$ a základní pozice všech čtyř duchů $[9;9]$. 
\chapter{Implementace}\label{sec:implementacechap}
Tato kapitola se zabývá implementací navržených číslicových obvodů na vývojovou desku Digilent Basys 2 v jazyce VHDL. 
\section{Úvod do implementace}
V této sekci popíšu očekávání od implementační části a dostupné prostředky, které využiji pro práci. Podsekce~\ref{sec:cileimplementace} popisuje očekávaný postup práce a v podsekci~\ref{sec:prostredkyproimplementaci} jsou popsány dostupné prostředky pro implementaci.  
\subsection{Cíle implementace}\label{sec:cileimplementace}
Cílem je v jazyce VHDL popsat obvod, který bude sesyntetizovatelný a výsledné propojení obvodů v FPGA bude funkcí přesně odpovídat navrženému obvodu. Strukturu popisu se pokusím navrhnout tak, aby výsledné moduly pro jednotlivé úlohy měly stejně pojmenované vstupy a výstupy a obecně práci co nejvíce sjednotit s návrhem. Postupovat v popisu obvodů budu stejně jako ve fázi návrhu, viz kapitola~\ref{sec:navrhhry} s případnými poznámkami k postupu a testování.
\subsection{Prostředky pro implementaci}\label{sec:prostredkyproimplementaci}
Pro implementaci využiji vývojovou desku Digilent Basys 2. Vývojová deska obsahuje vestavěné porty PS/2 a VGA, které jsou vhodné pro moji práci. Dále lze využít i vestavěný sedmisegmentový displej a LED diody pro počítání bodů a indikaci zbývajících životů hráče. K naprogramovanému FPGA na vývojové desce půjde připojit jakýkoliv funkční VGA monitor a jakákoliv funkční PS/2 klávesnice a správná funkce zůstane zachována. \par
Kód VHDL budu psát ve vývojovém prostředí Xilinx ISE, které podporuje syntézu kódu a vytvoření tzv. bitstreamu (informace, která je uložena do paměti FPGA) pro FPGA Xilinx Spartan-3E. Pro nahrání bitstreamu do FPGA využiji software Digilent Adept.
\section{Periferie}
V této sekci popíšu postup popisu jednotlivých modulů pro propojení periferií na základě návrhu. V podsekci~\ref{sec:sdimplement} popíšu implementaci návrhu modulu pro sedmisegmentový displej, v podsekci~\ref{sec:ps2implement} implementaci modulu pro PS/2 a podsekce~\ref{sec:vgaimplement} vysvětlí implementaci modulu pro VGA.
\subsection{Sedmisegmentový displej}\label{sec:sdimplement}
 Dle podsekce~\ref{sec:sedmisegmentdisplej} je cílem vytvořit entitu, která bude mít čtyři čtyřbitové vstupní hodnoty, jednu výstupní osmibitovou a jednu výstupní čtyřbitovou. Pojmenujme tuto entitu Segment\textunderscore Display. Aby měla entita stejnou funkci jako výsledný návrh segmentového displeje, bude vypadat takto: 
\begin{lstlisting}[language=VHDL]
entity Segment_Display is
    Port ( in_1 : in  STD_LOGIC_VECTOR (3 downto 0);
           in_2 : in  STD_LOGIC_VECTOR (3 downto 0);
           in_3 : in  STD_LOGIC_VECTOR (3 downto 0);
           in_4 : in  STD_LOGIC_VECTOR (3 downto 0);
           active_display : out  STD_LOGIC_VECTOR (3 downto 0);
           display_value : out  STD_LOGIC_VECTOR (7 downto 0);
           clk : in  STD_LOGIC;
           reset : in  STD_LOGIC);
end Segment_Display;
\end{lstlisting}
popis vnitřního zapojení je dle schématu. Modul jsem testoval tak, že jsem připojil spodní dva bity všech vstupních hodnot na všech osm přepínačů na desce a testoval, zda jde vidět správný výstup. Lidským okem bohužel ale bylo možné vidět problikávání displejů na frekvenci $30Hz$. Bohužel bylo možné lehce sledovat i vyšší frekvence, takže k uspokojivému výsledku jsem se dostal až po připojení šestnáctého a sedmnáctého bitu navrženého čítače ($763Hz$).
\subsection{PS/2}\label{sec:ps2implement}
Cílová entita dle podsekce~\ref{sec:ps2sub} bude vypadat následovně a pojmenuji ji PS2:
\begin{lstlisting}[language=VHDL]
entity PS2 is
    Port ( ps2_data : in  STD_LOGIC;
           ps2_clk : in  STD_LOGIC;
           clk : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           key : out  STD_LOGIC_VECTOR (7 downto 0);
           strobe : out  STD_LOGIC;
           extended : out  STD_LOGIC);
end PS2;
\end{lstlisting}
Vnitřní zapojení jsem rozdělil na dvě části, jimiž jsou datová cesta a kontrolér. Kontrolér je popis konečného stavového automatu (FSM) a datová cesta je zbytek obvodu. Tyto dvě části spojuji pomocí komponent ve vrchní entitě. Obvod je popsán stejně jako ve schématu. Pro popis posuvného registru jsem využil signál, kterému přiřazuji nové hodnoty pomocí operátoru bitového posunu, viz proces níže, který reprezentuje posuvný registr, kde signál shift\textunderscore register\textunderscore output je signál posuvného registru, ps2\textunderscore edge\textunderscore detected je signál detekující sestupnou hranu dle návrhu a ps2\textunderscore data\textunderscore synced je aktuální výstup synchronizéru pro datový signál: 
\begin{lstlisting}[language=VHDL]
shift_register_holding_key : process(clk)
begin
if(clk'event and clk='1') then -- rising edge on CLK          
	if(reset = '1') then -- reset
		shift_register_output <= (others => '0');
	else 
		if ps2_clk_edge_detected = '1' then
			shift_register_output <=
			 ps2_data_synced & 
			shift_register_output(10 downto 1);
		end if;
	end if;
end if;
end process;
\end{lstlisting}
Modul jsem testoval pomocí propojení se sedmisegmentovým displejem, kde bylo cílem zobrazovat v hexadecimální soustavě kód stisknuté klávesy po jejím stisknutí. Zde proběhlo testování bez problému.
\subsection{VGA}\label{sec:vgaimplement}
Entita VGA bude vypadat dle podsekce~\ref{sec:vgasub} takto:
\begin{lstlisting}[language=VHDL]
entity VGA is
    Port (	clk : in  STD_LOGIC;
            	reset : in  STD_LOGIC;
            	VSync : out  STD_LOGIC;
            	HSync : out  STD_LOGIC;
	  	HPos_out : out STD_LOGIC_VECTOR(9 downto 0);
	  	VPos_out : out STD_LOGIC_VECTOR(9 downto 0)
	);
end VGA;
\end{lstlisting}
Pro pohodlnou práci v tomto modulu jsem se rozhodl porovnávat hodnoty čítačů v komparátorech s konstantami, vytvořil jsem si tedy konstantu pro každou hodnotu týkající se časování dle specifikace VGA, viz:
\begin{lstlisting}[language=VHDL]
constant hva : integer := 640;
constant hfp : integer := 16;
constant hsp : integer := 96;
constant hbp  : integer := 48;

constant vva : integer := 480;
constant vfp : integer := 10;
constant vsp : integer := 2;
constant vbp : integer := 33;
\end{lstlisting}
Později při testování, když monitor hlásil neplatný vstup, jsem došel k výsledku, že pokud se aktuální vykreslovaná část nenachází ve viditelné části monitoru, tak je nutné vykreslovat černou barvu, resp. logické $'0'$ na pinech RGB. Přidal jsem do obvodu tedy další komparátor, jehož vstupem jsou aktuální vykreslované souřadnice H-Pos a V-Pos a výstupem je signál, který jsem pojmenoval active. active nabývá logické $'1'$ pokud jsou aktuální H-Pos a V-Pos ve viditelné zóně, viz následující proces:
\begin{lstlisting}[language=VHDL]
Activity_indicator : process(HPOS, VPOS)
begin
	if (HPOS < hva) and (VPOS < vva) then
		active <= '1';
else
		active <= '0'; 
end if;
end process;
\end{lstlisting}
Výstupy RGB musejí nyní být řízeny multiplexorem, který na základě vstupu active vykresluje buďto vybranou barvu, nebo černou v případě, že active nabývá logické $'0'$. Pro testování jsem na monitor pomocí komparátorů nakreslil bílé okraje. Vše nyní fungovalo, jak mělo.
\section{Logika hry}
\subsection{Celkové propojení}
Popis logiky hry probíhal jako v návrhu v sekci~\ref{sec:logikahry}. Kvůli menšímu rozsahu bylo možné uchovat stavový modul jako monolitickou část vrchní entity, která doposud propojovala periferie. Po lehkém rozšíření schématu z návrhové fáze může tato vrchní entita nyní vypadat jako na obrázku~\ref{fig:wholetoplevel}.
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/Implementation/WholeSchema.pdf}
\caption{Rozšířený návrh vrchní entity.}
\label{fig:wholetoplevel}
\end{figure} 
Jediným neznámým signálem zde je lifes\textunderscore LED, který je může být připojen na LED diody na vývojové desce a pomocí dekodéru $1 z N$ zobrazovat zbývající životy hráče a $n$ jsou signály o pozici každého prvku ve hře (multiplexor pro vyhodnocování signálů RGB bude mít více podmínek z důvodu otáčení postav a vykreslování černé barvy, pokud se aktuální vykreslovaný pixel nenalézá ve viditelné části VGA). Vrchní entita bude tedy vypadat následovně:
\begin{lstlisting}[language=VHDL]
entity TuxManGame is
    Port ( ps2_clk : in  STD_LOGIC;
	ps2_data : in  STD_LOGIC;
	R,G : out STD_LOGIC_VECTOR(2 downto 0);
	B : out STD_LOGIC_VECTOR(1 downto 0);
	HSync : out STD_LOGIC;
	VSync : out STD_LOGIC;
	active_segment_display : out STD_LOGIC_VECTOR (3 downto 0);
	segment_display_value : out STD_LOGIC_VECTOR (7 downto 0);
	lifes_LED : out STD_LOGIC_VECTOR (2 downto 0);
	reset : in  STD_LOGIC;
	clk : in  STD_LOGIC);
end TuxManGame;
\end{lstlisting}
\subsection{Využití dostupných prostředků a problémy implementace}\label{sec:implementproblems}
Při prvotním návrhu, viz~\ref{sec:pohybpomape}, kde si každý z pohyblivých prvků inicializoval vlastní paměť jsem se setkal s problémem, kde v FPGA nebylo dostatek místa pro tyto paměti. Při pokusu o implementaci s tímto řešením byla od Xilinx ISE vypsána chybová hláška a ve shrnutí, viz obrázek~\ref{fig:error}, byl vyhlášen nedostatek LUTů. 
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/Errors/NotEnoughMemory.png}
\caption{Shrnutí Xilinx ISE s upozorněním na nedostatek prvků v FPGA.}
\label{fig:error}
\end{figure} 
Po optimalizaci pomocí arbitrace sběrnice se problém již nenaskytoval. Aktuální shrnutí využitých dostupných prostředků je na obrázku~\ref{fig:usage}
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/Errors/EnoughNow.png}
\caption{Aktuální shrnutí využitých dostupných prostředků.}
\label{fig:usage}
\end{figure} 
\chapter{Testování}\label{sec:testovanichap}
Moduly jsem testoval postupně pokaždé, když jsem dokončil jejich implementaci. První byl modul pro práci se sedmisegmentovým displejem, který jsem otestoval tak, že jsem na spodní dva bity každého ze vstupů připojil přepínače z vývojové desky Digilent Basys 2 (pro čtyři číslice sedmisegmentového displeje osm přepínačů). Sedmisegmentový displej správně zobrazoval příslušné hodnoty. \par 
Druhým modulem byl PS/2 modul, jenž jsem testoval za pomocí sedmisegmentového displeje. cílem bylo, aby se na sedmisegmentovém displeji při stisknutí klávesy zobrazil příslušný kód klávesy, což bylo úspěšné, viz obrázek~\ref{fig:ps2test}.\par
\begin{figure}
\centering
\includegraphics[width=0.8\columnwidth]{/Test/PS2.jpg}
\caption{Testování modulu pro PS/2.}
\label{fig:ps2test}
\end{figure}
Dalším modulem byl VGA, jehož testování probíhalo samostatně. Po správné optimalizaci synchronizačních signálů jsem pomocí komparátorů vykreslil bílý rámeček na VGA monitor a sledoval, zda má časování nějaké nesrovnalosti. Když testování VGA proběhlo bez problému, tak jsem začal s implementací hry samotné.
\par
Hru jsem dále testoval postupným hraním hry s každou novou částí. Prvním úkolem bylo vytvořit herní mapu, na které by se dalo hrát. Poté jsem do ní vložil první postavu, která šla ovládat PS/2 klávesnicí a zastavila se před zdmi na mapě. Když tato část fungovala, tak jsem přidal na mapu body, které by mohla postava sbírat. Poslední částí byly postavy řízené automatem, jejichž testování znovu probíhalo postupným hraním. 
\par
Toto postupné testování bylo velmi přívětivé a umožnil mi ho hierarchický návrh, který jsem při postupu dodržoval. Považuji ho za velkou výhodu při postupu návrhu a implementace logických číslicových obvodů. Když hra byla kompletní a všechny prvky implementované, tak jsem strávil v kuse dvě hodiny hraním a nenarazil jsem na žádnou závadu. Hra je plně hratelná dle návrhu. Ukázka hry je na obrázku~\ref{fig:gametest}.\par
\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{/Test/WorkGame.jpg}
\caption{Testování hry.}
\label{fig:gametest}
\end{figure}

 \chapter*{Závěr}
 \addcontentsline{toc}{chapter}{Závěr}
První a nejdůležitější součástí práce bylo naučit se základní principy číslicového návrhu . Na začátku práce mé znalosti nesahaly ani do čtvrtiny teoretické části této odborné práce. Po několika hodinách strávených přednáškami konzultanta odborné práce jsem byl již schopný z vykládané teorie vytvořit první číslicové návrhy. \par
Po několika navržených číslicových obvodech a s dostatečnou teoretickou znalostí bylo možné začít vymýšlet, jak budu postupovat při návrhu herní logiky v číslicovém obvodu. Chytře jsem zvolil postup práce, který umožnil začít nejjednodušším návrhem a končit tím náročnějším. S každým novým návrhem přišly nové znalosti, které bylo možné využívat při dalších návrzích. Součástí těchto nových znalostí nebyly pouze další logické bloky, ale také například komunikační protokoly sedmisegmentového displeje, PS/2 a VGA. Přes náročné začátky se ke konci návrhové fáze práce dalo říct, že poslední návrhy číslicových obvodů, které realizovaly logiku hry, probíhaly téměř bez problémů a o dost efektivněji, než na začátku. \par
 Nedílnou součástí práce bylo naučit se práce s programovatelnými hradlovými poli, aby bylo možné číslicové návrhy za chodu testovat a práci implementovat. Po osvojení jazyka popisujícího hardware a pochopení logické syntézy se všemi náležitostmi vybraného programovatelného hradlového pole nebyl problém přenést návrh do implementace. \par
Obecně práce probíhala dle očekávání a výstup každé jednotlivé části byl po otestování a přípandé úpravě uspokojivý. Konečným výstupem je tedy funkční číslicový logický obvod, který má funkčnost, jakou by měl mít podle jeho návrhu.  \par
Dá se tedy říci, že všechny cíle práce, jenž byly navrhnout číslicový obvod realizující arkádovou hru a implementovat jej na vybrané programovatelné hradlové pole,  byly splněny. Výslednou implementaci jsem testoval ovládáním dle její funkce. Po několika testovacích pokusech číslicový logický obvod pořád vykazoval korektní činnost. \par
Během práce jsem využíval verzovacího systému a celý projekt uvolňuji pod MIT licencí jako open-source a je k dispozici na stránkách GitHub~\cite{githubrepo}.

\bibliographystyle{ieeetran}
\bibliography{bibfile}

\chapter*{Přílohy}
\begin{tabbing}
    TuxMan.rar \hspace{5em} \= Zdrojové kódy a bitstream  \\
    Images.rar \>  obrázky \\
\end{tabbing}
\end{document}